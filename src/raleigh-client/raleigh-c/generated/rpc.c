
/* File autogenerated, do not edit */
#include <zcl/global.h>
#include <zcl/string.h>
#include <zcl/debug.h>

#include "rpc.h"


struct status *status_alloc (struct status *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct status);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->status_ialloc = 1;
  } else {
    msg->status_ialloc = 0;
  }

  z_memzero(msg->status_fields_bitmap, 1);
  msg->code = 0;
  status_set_code(msg);
  z_bytes_ref_reset(&(msg->message));
  return(msg);
}

void status_free (struct status *msg) {
   z_bytes_ref_release(&(msg->message));
  if (msg->status_ialloc)
    z_memory_struct_free(z_global_memory(), struct status, msg);
}

int status_parse (struct status *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* uint64 code */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->code));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->status_fields_bitmap, 0);
        break;
      }

      case 2: { /* bytes message */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->message));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->status_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t status_size (struct status *msg) {
  size_t size = 0;
  
  if (status_has_code(msg)) {
    size_t length = z_uint64_size(msg->code);
    size += z_encoded_field_length(1, length) + length;
  }

  if (status_has_message(msg)) {
    size += z_encoded_field_length(2, msg->message.slice.size);
    size += msg->message.slice.size;
  }
  return(size);
}

int status_write (struct status *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (status_has_code(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->code);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (status_has_message(msg)) {
    r = z_write_field_bytes(buffer, 2, &(msg->message));
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void status_dump (FILE *stream, const struct status *msg) {
  fprintf(stream, "status {");
  
  fprintf(stream, "\n  1: uint64 code = ");
  if (status_has_code(msg)) {
    z_dump_uint64(stream, msg->code);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes message = ");
  if (status_has_message(msg)) {
    z_dump_bytes(stream, &(msg->message));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct semantic_open_request *semantic_open_request_alloc (struct semantic_open_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_open_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_open_request_ialloc = 1;
  } else {
    msg->semantic_open_request_ialloc = 0;
  }

  z_memzero(msg->semantic_open_request_fields_bitmap, 1);
  z_bytes_ref_reset(&(msg->name));
  return(msg);
}

void semantic_open_request_free (struct semantic_open_request *msg) {
   z_bytes_ref_release(&(msg->name));
  if (msg->semantic_open_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_open_request, msg);
}

int semantic_open_request_parse (struct semantic_open_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* bytes name */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->name));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_open_request_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_open_request_size (struct semantic_open_request *msg) {
  size_t size = 0;
  
  if (semantic_open_request_has_name(msg)) {
    size += z_encoded_field_length(1, msg->name.slice.size);
    size += msg->name.slice.size;
  }
  return(size);
}

int semantic_open_request_write (struct semantic_open_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_open_request_has_name(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->name));
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void semantic_open_request_dump (FILE *stream, const struct semantic_open_request *msg) {
  fprintf(stream, "semantic_open_request {");
  
  fprintf(stream, "\n  1: bytes name = ");
  if (semantic_open_request_has_name(msg)) {
    z_dump_bytes(stream, &(msg->name));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct semantic_open_response *semantic_open_response_alloc (struct semantic_open_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_open_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_open_response_ialloc = 1;
  } else {
    msg->semantic_open_response_ialloc = 0;
  }

  z_memzero(msg->semantic_open_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void semantic_open_response_free (struct semantic_open_response *msg) {
   status_free(&(msg->status));
  if (msg->semantic_open_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_open_response, msg);
}

int semantic_open_response_parse (struct semantic_open_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_open_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_open_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_open_response_size (struct semantic_open_response *msg) {
  size_t size = 0;
  
  if (semantic_open_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (semantic_open_response_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int semantic_open_response_write (struct semantic_open_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_open_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (semantic_open_response_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void semantic_open_response_dump (FILE *stream, const struct semantic_open_response *msg) {
  fprintf(stream, "semantic_open_response {");
  
  fprintf(stream, "\n  1: uint64 oid = ");
  if (semantic_open_response_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct semantic_create_request *semantic_create_request_alloc (struct semantic_create_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_create_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_create_request_ialloc = 1;
  } else {
    msg->semantic_create_request_ialloc = 0;
  }

  z_memzero(msg->semantic_create_request_fields_bitmap, 1);
  z_bytes_ref_reset(&(msg->name));
  z_bytes_ref_reset(&(msg->type));
  return(msg);
}

void semantic_create_request_free (struct semantic_create_request *msg) {
   z_bytes_ref_release(&(msg->name));
   z_bytes_ref_release(&(msg->type));
  if (msg->semantic_create_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_create_request, msg);
}

int semantic_create_request_parse (struct semantic_create_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* bytes name */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->name));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_create_request_fields_bitmap, 0);
        break;
      }

      case 2: { /* bytes type */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->type));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_create_request_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_create_request_size (struct semantic_create_request *msg) {
  size_t size = 0;
  
  if (semantic_create_request_has_name(msg)) {
    size += z_encoded_field_length(1, msg->name.slice.size);
    size += msg->name.slice.size;
  }

  if (semantic_create_request_has_type(msg)) {
    size += z_encoded_field_length(2, msg->type.slice.size);
    size += msg->type.slice.size;
  }
  return(size);
}

int semantic_create_request_write (struct semantic_create_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_create_request_has_name(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->name));
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (semantic_create_request_has_type(msg)) {
    r = z_write_field_bytes(buffer, 2, &(msg->type));
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void semantic_create_request_dump (FILE *stream, const struct semantic_create_request *msg) {
  fprintf(stream, "semantic_create_request {");
  
  fprintf(stream, "\n  1: bytes name = ");
  if (semantic_create_request_has_name(msg)) {
    z_dump_bytes(stream, &(msg->name));
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes type = ");
  if (semantic_create_request_has_type(msg)) {
    z_dump_bytes(stream, &(msg->type));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct semantic_create_response *semantic_create_response_alloc (struct semantic_create_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_create_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_create_response_ialloc = 1;
  } else {
    msg->semantic_create_response_ialloc = 0;
  }

  z_memzero(msg->semantic_create_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void semantic_create_response_free (struct semantic_create_response *msg) {
   status_free(&(msg->status));
  if (msg->semantic_create_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_create_response, msg);
}

int semantic_create_response_parse (struct semantic_create_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_create_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_create_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_create_response_size (struct semantic_create_response *msg) {
  size_t size = 0;
  
  if (semantic_create_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (semantic_create_response_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int semantic_create_response_write (struct semantic_create_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_create_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (semantic_create_response_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void semantic_create_response_dump (FILE *stream, const struct semantic_create_response *msg) {
  fprintf(stream, "semantic_create_response {");
  
  fprintf(stream, "\n  1: uint64 oid = ");
  if (semantic_create_response_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct semantic_delete_request *semantic_delete_request_alloc (struct semantic_delete_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_delete_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_delete_request_ialloc = 1;
  } else {
    msg->semantic_delete_request_ialloc = 0;
  }

  z_memzero(msg->semantic_delete_request_fields_bitmap, 1);
  z_bytes_ref_reset(&(msg->name));
  return(msg);
}

void semantic_delete_request_free (struct semantic_delete_request *msg) {
   z_bytes_ref_release(&(msg->name));
  if (msg->semantic_delete_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_delete_request, msg);
}

int semantic_delete_request_parse (struct semantic_delete_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* bytes name */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->name));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_delete_request_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_delete_request_size (struct semantic_delete_request *msg) {
  size_t size = 0;
  
  if (semantic_delete_request_has_name(msg)) {
    size += z_encoded_field_length(1, msg->name.slice.size);
    size += msg->name.slice.size;
  }
  return(size);
}

int semantic_delete_request_write (struct semantic_delete_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_delete_request_has_name(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->name));
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void semantic_delete_request_dump (FILE *stream, const struct semantic_delete_request *msg) {
  fprintf(stream, "semantic_delete_request {");
  
  fprintf(stream, "\n  1: bytes name = ");
  if (semantic_delete_request_has_name(msg)) {
    z_dump_bytes(stream, &(msg->name));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct semantic_delete_response *semantic_delete_response_alloc (struct semantic_delete_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_delete_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_delete_response_ialloc = 1;
  } else {
    msg->semantic_delete_response_ialloc = 0;
  }

  z_memzero(msg->semantic_delete_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void semantic_delete_response_free (struct semantic_delete_response *msg) {
   status_free(&(msg->status));
  if (msg->semantic_delete_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_delete_response, msg);
}

int semantic_delete_response_parse (struct semantic_delete_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_delete_response_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_delete_response_size (struct semantic_delete_response *msg) {
  size_t size = 0;
  
  if (semantic_delete_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
  return(size);
}

int semantic_delete_response_write (struct semantic_delete_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_delete_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }
  return(r);
}

void semantic_delete_response_dump (FILE *stream, const struct semantic_delete_response *msg) {
  fprintf(stream, "semantic_delete_response {");
  
  fprintf(stream, "\n}\n");
}

struct semantic_rename_request *semantic_rename_request_alloc (struct semantic_rename_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_rename_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_rename_request_ialloc = 1;
  } else {
    msg->semantic_rename_request_ialloc = 0;
  }

  z_memzero(msg->semantic_rename_request_fields_bitmap, 1);
  z_bytes_ref_reset(&(msg->old_name));
  z_bytes_ref_reset(&(msg->new_name));
  return(msg);
}

void semantic_rename_request_free (struct semantic_rename_request *msg) {
   z_bytes_ref_release(&(msg->old_name));
   z_bytes_ref_release(&(msg->new_name));
  if (msg->semantic_rename_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_rename_request, msg);
}

int semantic_rename_request_parse (struct semantic_rename_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* bytes old_name */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->old_name));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_rename_request_fields_bitmap, 0);
        break;
      }

      case 2: { /* bytes new_name */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->new_name));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_rename_request_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_rename_request_size (struct semantic_rename_request *msg) {
  size_t size = 0;
  
  if (semantic_rename_request_has_old_name(msg)) {
    size += z_encoded_field_length(1, msg->old_name.slice.size);
    size += msg->old_name.slice.size;
  }

  if (semantic_rename_request_has_new_name(msg)) {
    size += z_encoded_field_length(2, msg->new_name.slice.size);
    size += msg->new_name.slice.size;
  }
  return(size);
}

int semantic_rename_request_write (struct semantic_rename_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_rename_request_has_old_name(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->old_name));
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (semantic_rename_request_has_new_name(msg)) {
    r = z_write_field_bytes(buffer, 2, &(msg->new_name));
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void semantic_rename_request_dump (FILE *stream, const struct semantic_rename_request *msg) {
  fprintf(stream, "semantic_rename_request {");
  
  fprintf(stream, "\n  1: bytes old_name = ");
  if (semantic_rename_request_has_old_name(msg)) {
    z_dump_bytes(stream, &(msg->old_name));
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes new_name = ");
  if (semantic_rename_request_has_new_name(msg)) {
    z_dump_bytes(stream, &(msg->new_name));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct semantic_rename_response *semantic_rename_response_alloc (struct semantic_rename_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct semantic_rename_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->semantic_rename_response_ialloc = 1;
  } else {
    msg->semantic_rename_response_ialloc = 0;
  }

  z_memzero(msg->semantic_rename_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void semantic_rename_response_free (struct semantic_rename_response *msg) {
   status_free(&(msg->status));
  if (msg->semantic_rename_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct semantic_rename_response, msg);
}

int semantic_rename_response_parse (struct semantic_rename_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->semantic_rename_response_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t semantic_rename_response_size (struct semantic_rename_response *msg) {
  size_t size = 0;
  
  if (semantic_rename_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
  return(size);
}

int semantic_rename_response_write (struct semantic_rename_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (semantic_rename_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }
  return(r);
}

void semantic_rename_response_dump (FILE *stream, const struct semantic_rename_response *msg) {
  fprintf(stream, "semantic_rename_response {");
  
  fprintf(stream, "\n}\n");
}

struct transaction_create_request *transaction_create_request_alloc (struct transaction_create_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct transaction_create_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->transaction_create_request_ialloc = 1;
  } else {
    msg->transaction_create_request_ialloc = 0;
  }

  z_memzero(msg->transaction_create_request_fields_bitmap, 0);

  return(msg);
}

void transaction_create_request_free (struct transaction_create_request *msg) {

  if (msg->transaction_create_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct transaction_create_request, msg);
}

int transaction_create_request_parse (struct transaction_create_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t transaction_create_request_size (struct transaction_create_request *msg) {
  size_t size = 0;
  
  return(size);
}

int transaction_create_request_write (struct transaction_create_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void transaction_create_request_dump (FILE *stream, const struct transaction_create_request *msg) {
  fprintf(stream, "transaction_create_request {");
  
  fprintf(stream, "\n}\n");
}

struct transaction_create_response *transaction_create_response_alloc (struct transaction_create_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct transaction_create_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->transaction_create_response_ialloc = 1;
  } else {
    msg->transaction_create_response_ialloc = 0;
  }

  z_memzero(msg->transaction_create_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void transaction_create_response_free (struct transaction_create_response *msg) {
   status_free(&(msg->status));
  if (msg->transaction_create_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct transaction_create_response, msg);
}

int transaction_create_response_parse (struct transaction_create_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->transaction_create_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->transaction_create_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t transaction_create_response_size (struct transaction_create_response *msg) {
  size_t size = 0;
  
  if (transaction_create_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (transaction_create_response_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int transaction_create_response_write (struct transaction_create_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (transaction_create_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (transaction_create_response_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void transaction_create_response_dump (FILE *stream, const struct transaction_create_response *msg) {
  fprintf(stream, "transaction_create_response {");
  
  fprintf(stream, "\n  1: uint64 txn_id = ");
  if (transaction_create_response_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct transaction_commit_request *transaction_commit_request_alloc (struct transaction_commit_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct transaction_commit_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->transaction_commit_request_ialloc = 1;
  } else {
    msg->transaction_commit_request_ialloc = 0;
  }

  z_memzero(msg->transaction_commit_request_fields_bitmap, 1);

  return(msg);
}

void transaction_commit_request_free (struct transaction_commit_request *msg) {

  if (msg->transaction_commit_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct transaction_commit_request, msg);
}

int transaction_commit_request_parse (struct transaction_commit_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->transaction_commit_request_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t transaction_commit_request_size (struct transaction_commit_request *msg) {
  size_t size = 0;
  
  if (transaction_commit_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int transaction_commit_request_write (struct transaction_commit_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (transaction_commit_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void transaction_commit_request_dump (FILE *stream, const struct transaction_commit_request *msg) {
  fprintf(stream, "transaction_commit_request {");
  
  fprintf(stream, "\n  1: uint64 txn_id = ");
  if (transaction_commit_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct transaction_commit_response *transaction_commit_response_alloc (struct transaction_commit_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct transaction_commit_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->transaction_commit_response_ialloc = 1;
  } else {
    msg->transaction_commit_response_ialloc = 0;
  }

  z_memzero(msg->transaction_commit_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void transaction_commit_response_free (struct transaction_commit_response *msg) {
   status_free(&(msg->status));
  if (msg->transaction_commit_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct transaction_commit_response, msg);
}

int transaction_commit_response_parse (struct transaction_commit_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->transaction_commit_response_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t transaction_commit_response_size (struct transaction_commit_response *msg) {
  size_t size = 0;
  
  if (transaction_commit_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
  return(size);
}

int transaction_commit_response_write (struct transaction_commit_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (transaction_commit_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }
  return(r);
}

void transaction_commit_response_dump (FILE *stream, const struct transaction_commit_response *msg) {
  fprintf(stream, "transaction_commit_response {");
  
  fprintf(stream, "\n}\n");
}

struct transaction_rollback_request *transaction_rollback_request_alloc (struct transaction_rollback_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct transaction_rollback_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->transaction_rollback_request_ialloc = 1;
  } else {
    msg->transaction_rollback_request_ialloc = 0;
  }

  z_memzero(msg->transaction_rollback_request_fields_bitmap, 1);

  return(msg);
}

void transaction_rollback_request_free (struct transaction_rollback_request *msg) {

  if (msg->transaction_rollback_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct transaction_rollback_request, msg);
}

int transaction_rollback_request_parse (struct transaction_rollback_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->transaction_rollback_request_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t transaction_rollback_request_size (struct transaction_rollback_request *msg) {
  size_t size = 0;
  
  if (transaction_rollback_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int transaction_rollback_request_write (struct transaction_rollback_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (transaction_rollback_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void transaction_rollback_request_dump (FILE *stream, const struct transaction_rollback_request *msg) {
  fprintf(stream, "transaction_rollback_request {");
  
  fprintf(stream, "\n  1: uint64 txn_id = ");
  if (transaction_rollback_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct transaction_rollback_response *transaction_rollback_response_alloc (struct transaction_rollback_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct transaction_rollback_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->transaction_rollback_response_ialloc = 1;
  } else {
    msg->transaction_rollback_response_ialloc = 0;
  }

  z_memzero(msg->transaction_rollback_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void transaction_rollback_response_free (struct transaction_rollback_response *msg) {
   status_free(&(msg->status));
  if (msg->transaction_rollback_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct transaction_rollback_response, msg);
}

int transaction_rollback_response_parse (struct transaction_rollback_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->transaction_rollback_response_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t transaction_rollback_response_size (struct transaction_rollback_response *msg) {
  size_t size = 0;
  
  if (transaction_rollback_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
  return(size);
}

int transaction_rollback_response_write (struct transaction_rollback_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (transaction_rollback_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }
  return(r);
}

void transaction_rollback_response_dump (FILE *stream, const struct transaction_rollback_response *msg) {
  fprintf(stream, "transaction_rollback_response {");
  
  fprintf(stream, "\n}\n");
}

struct number_get_request *number_get_request_alloc (struct number_get_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_get_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_get_request_ialloc = 1;
  } else {
    msg->number_get_request_ialloc = 0;
  }

  z_memzero(msg->number_get_request_fields_bitmap, 1);
  msg->txn_id = 0;
  number_get_request_set_txn_id(msg);
  return(msg);
}

void number_get_request_free (struct number_get_request *msg) {

  if (msg->number_get_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_get_request, msg);
}

int number_get_request_parse (struct number_get_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_get_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_get_request_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_get_request_size (struct number_get_request *msg) {
  size_t size = 0;
  
  if (number_get_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (number_get_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int number_get_request_write (struct number_get_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_get_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_get_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void number_get_request_dump (FILE *stream, const struct number_get_request *msg) {
  fprintf(stream, "number_get_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (number_get_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (number_get_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_get_response *number_get_response_alloc (struct number_get_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_get_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_get_response_ialloc = 1;
  } else {
    msg->number_get_response_ialloc = 0;
  }

  z_memzero(msg->number_get_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void number_get_response_free (struct number_get_response *msg) {
   status_free(&(msg->status));
  if (msg->number_get_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_get_response, msg);
}

int number_get_response_parse (struct number_get_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_get_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_get_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_get_response_size (struct number_get_response *msg) {
  size_t size = 0;
  
  if (number_get_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (number_get_response_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int number_get_response_write (struct number_get_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_get_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_get_response_has_value(msg)) {
    r = z_write_field_int64(buffer, 1, msg->value);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void number_get_response_dump (FILE *stream, const struct number_get_response *msg) {
  fprintf(stream, "number_get_response {");
  
  fprintf(stream, "\n  1: int64 value = ");
  if (number_get_response_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_set_request *number_set_request_alloc (struct number_set_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_set_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_set_request_ialloc = 1;
  } else {
    msg->number_set_request_ialloc = 0;
  }

  z_memzero(msg->number_set_request_fields_bitmap, 1);
  msg->txn_id = 0;
  number_set_request_set_txn_id(msg);
  return(msg);
}

void number_set_request_free (struct number_set_request *msg) {

  if (msg->number_set_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_set_request, msg);
}

int number_set_request_parse (struct number_set_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_set_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_set_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_set_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_set_request_size (struct number_set_request *msg) {
  size_t size = 0;
  
  if (number_set_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (number_set_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (number_set_request_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(2, length) + length;
  }
  return(size);
}

int number_set_request_write (struct number_set_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_set_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_set_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (number_set_request_has_value(msg)) {
    r = z_write_field_int64(buffer, 2, msg->value);
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void number_set_request_dump (FILE *stream, const struct number_set_request *msg) {
  fprintf(stream, "number_set_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (number_set_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (number_set_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int64 value = ");
  if (number_set_request_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_set_response *number_set_response_alloc (struct number_set_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_set_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_set_response_ialloc = 1;
  } else {
    msg->number_set_response_ialloc = 0;
  }

  z_memzero(msg->number_set_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void number_set_response_free (struct number_set_response *msg) {
   status_free(&(msg->status));
  if (msg->number_set_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_set_response, msg);
}

int number_set_response_parse (struct number_set_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_set_response_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_set_response_size (struct number_set_response *msg) {
  size_t size = 0;
  
  if (number_set_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
  return(size);
}

int number_set_response_write (struct number_set_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_set_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }
  return(r);
}

void number_set_response_dump (FILE *stream, const struct number_set_response *msg) {
  fprintf(stream, "number_set_response {");
  
  fprintf(stream, "\n}\n");
}

struct number_cas_request *number_cas_request_alloc (struct number_cas_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_cas_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_cas_request_ialloc = 1;
  } else {
    msg->number_cas_request_ialloc = 0;
  }

  z_memzero(msg->number_cas_request_fields_bitmap, 1);
  msg->txn_id = 0;
  number_cas_request_set_txn_id(msg);
  return(msg);
}

void number_cas_request_free (struct number_cas_request *msg) {

  if (msg->number_cas_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_cas_request, msg);
}

int number_cas_request_parse (struct number_cas_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_cas_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_cas_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int64 old_value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->old_value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_cas_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* int64 new_value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->new_value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_cas_request_fields_bitmap, 3);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_cas_request_size (struct number_cas_request *msg) {
  size_t size = 0;
  
  if (number_cas_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (number_cas_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (number_cas_request_has_old_value(msg)) {
    size_t length = z_int64_size(msg->old_value);
    size += z_encoded_field_length(2, length) + length;
  }

  if (number_cas_request_has_new_value(msg)) {
    size_t length = z_int64_size(msg->new_value);
    size += z_encoded_field_length(3, length) + length;
  }
  return(size);
}

int number_cas_request_write (struct number_cas_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_cas_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_cas_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (number_cas_request_has_old_value(msg)) {
    r = z_write_field_int64(buffer, 2, msg->old_value);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (number_cas_request_has_new_value(msg)) {
    r = z_write_field_int64(buffer, 3, msg->new_value);
    if (Z_UNLIKELY(r)) return(-3);
  }
  return(r);
}

void number_cas_request_dump (FILE *stream, const struct number_cas_request *msg) {
  fprintf(stream, "number_cas_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (number_cas_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (number_cas_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int64 old_value = ");
  if (number_cas_request_has_old_value(msg)) {
    z_dump_int64(stream, msg->old_value);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: int64 new_value = ");
  if (number_cas_request_has_new_value(msg)) {
    z_dump_int64(stream, msg->new_value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_cas_response *number_cas_response_alloc (struct number_cas_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_cas_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_cas_response_ialloc = 1;
  } else {
    msg->number_cas_response_ialloc = 0;
  }

  z_memzero(msg->number_cas_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void number_cas_response_free (struct number_cas_response *msg) {
   status_free(&(msg->status));
  if (msg->number_cas_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_cas_response, msg);
}

int number_cas_response_parse (struct number_cas_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_cas_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_cas_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_cas_response_size (struct number_cas_response *msg) {
  size_t size = 0;
  
  if (number_cas_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (number_cas_response_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int number_cas_response_write (struct number_cas_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_cas_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_cas_response_has_value(msg)) {
    r = z_write_field_int64(buffer, 1, msg->value);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void number_cas_response_dump (FILE *stream, const struct number_cas_response *msg) {
  fprintf(stream, "number_cas_response {");
  
  fprintf(stream, "\n  1: int64 value = ");
  if (number_cas_response_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_add_request *number_add_request_alloc (struct number_add_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_add_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_add_request_ialloc = 1;
  } else {
    msg->number_add_request_ialloc = 0;
  }

  z_memzero(msg->number_add_request_fields_bitmap, 1);
  msg->txn_id = 0;
  number_add_request_set_txn_id(msg);
  return(msg);
}

void number_add_request_free (struct number_add_request *msg) {

  if (msg->number_add_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_add_request, msg);
}

int number_add_request_parse (struct number_add_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_add_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_add_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_add_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_add_request_size (struct number_add_request *msg) {
  size_t size = 0;
  
  if (number_add_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (number_add_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (number_add_request_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(2, length) + length;
  }
  return(size);
}

int number_add_request_write (struct number_add_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_add_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_add_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (number_add_request_has_value(msg)) {
    r = z_write_field_int64(buffer, 2, msg->value);
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void number_add_request_dump (FILE *stream, const struct number_add_request *msg) {
  fprintf(stream, "number_add_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (number_add_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (number_add_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int64 value = ");
  if (number_add_request_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_add_response *number_add_response_alloc (struct number_add_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_add_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_add_response_ialloc = 1;
  } else {
    msg->number_add_response_ialloc = 0;
  }

  z_memzero(msg->number_add_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void number_add_response_free (struct number_add_response *msg) {
   status_free(&(msg->status));
  if (msg->number_add_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_add_response, msg);
}

int number_add_response_parse (struct number_add_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_add_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_add_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_add_response_size (struct number_add_response *msg) {
  size_t size = 0;
  
  if (number_add_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (number_add_response_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int number_add_response_write (struct number_add_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_add_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_add_response_has_value(msg)) {
    r = z_write_field_int64(buffer, 1, msg->value);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void number_add_response_dump (FILE *stream, const struct number_add_response *msg) {
  fprintf(stream, "number_add_response {");
  
  fprintf(stream, "\n  1: int64 value = ");
  if (number_add_response_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_mul_request *number_mul_request_alloc (struct number_mul_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_mul_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_mul_request_ialloc = 1;
  } else {
    msg->number_mul_request_ialloc = 0;
  }

  z_memzero(msg->number_mul_request_fields_bitmap, 1);
  msg->txn_id = 0;
  number_mul_request_set_txn_id(msg);
  return(msg);
}

void number_mul_request_free (struct number_mul_request *msg) {

  if (msg->number_mul_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_mul_request, msg);
}

int number_mul_request_parse (struct number_mul_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_mul_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_mul_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_mul_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_mul_request_size (struct number_mul_request *msg) {
  size_t size = 0;
  
  if (number_mul_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (number_mul_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (number_mul_request_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(2, length) + length;
  }
  return(size);
}

int number_mul_request_write (struct number_mul_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_mul_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_mul_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (number_mul_request_has_value(msg)) {
    r = z_write_field_int64(buffer, 2, msg->value);
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void number_mul_request_dump (FILE *stream, const struct number_mul_request *msg) {
  fprintf(stream, "number_mul_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (number_mul_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (number_mul_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int64 value = ");
  if (number_mul_request_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_mul_response *number_mul_response_alloc (struct number_mul_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_mul_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_mul_response_ialloc = 1;
  } else {
    msg->number_mul_response_ialloc = 0;
  }

  z_memzero(msg->number_mul_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void number_mul_response_free (struct number_mul_response *msg) {
   status_free(&(msg->status));
  if (msg->number_mul_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_mul_response, msg);
}

int number_mul_response_parse (struct number_mul_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_mul_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_mul_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_mul_response_size (struct number_mul_response *msg) {
  size_t size = 0;
  
  if (number_mul_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (number_mul_response_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int number_mul_response_write (struct number_mul_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_mul_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_mul_response_has_value(msg)) {
    r = z_write_field_int64(buffer, 1, msg->value);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void number_mul_response_dump (FILE *stream, const struct number_mul_response *msg) {
  fprintf(stream, "number_mul_response {");
  
  fprintf(stream, "\n  1: int64 value = ");
  if (number_mul_response_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_div_request *number_div_request_alloc (struct number_div_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_div_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_div_request_ialloc = 1;
  } else {
    msg->number_div_request_ialloc = 0;
  }

  z_memzero(msg->number_div_request_fields_bitmap, 1);
  msg->txn_id = 0;
  number_div_request_set_txn_id(msg);
  return(msg);
}

void number_div_request_free (struct number_div_request *msg) {

  if (msg->number_div_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_div_request, msg);
}

int number_div_request_parse (struct number_div_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_div_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_div_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_div_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_div_request_size (struct number_div_request *msg) {
  size_t size = 0;
  
  if (number_div_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (number_div_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (number_div_request_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(2, length) + length;
  }
  return(size);
}

int number_div_request_write (struct number_div_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_div_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_div_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (number_div_request_has_value(msg)) {
    r = z_write_field_int64(buffer, 2, msg->value);
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void number_div_request_dump (FILE *stream, const struct number_div_request *msg) {
  fprintf(stream, "number_div_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (number_div_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (number_div_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int64 value = ");
  if (number_div_request_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct number_div_response *number_div_response_alloc (struct number_div_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct number_div_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->number_div_response_ialloc = 1;
  } else {
    msg->number_div_response_ialloc = 0;
  }

  z_memzero(msg->number_div_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void number_div_response_free (struct number_div_response *msg) {
   status_free(&(msg->status));
  if (msg->number_div_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct number_div_response, msg);
}

int number_div_response_parse (struct number_div_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_div_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* int64 mod */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->mod));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_div_response_fields_bitmap, 1);
        break;
      }

      case 2: { /* int64 value */
        if (Z_UNLIKELY(length > sizeof(int64_t))) return(-1);
        r = z_reader_decode_int64(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->number_div_response_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t number_div_response_size (struct number_div_response *msg) {
  size_t size = 0;
  
  if (number_div_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (number_div_response_has_mod(msg)) {
    size_t length = z_int64_size(msg->mod);
    size += z_encoded_field_length(1, length) + length;
  }

  if (number_div_response_has_value(msg)) {
    size_t length = z_int64_size(msg->value);
    size += z_encoded_field_length(2, length) + length;
  }
  return(size);
}

int number_div_response_write (struct number_div_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (number_div_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (number_div_response_has_mod(msg)) {
    r = z_write_field_int64(buffer, 1, msg->mod);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (number_div_response_has_value(msg)) {
    r = z_write_field_int64(buffer, 2, msg->value);
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void number_div_response_dump (FILE *stream, const struct number_div_response *msg) {
  fprintf(stream, "number_div_response {");
  
  fprintf(stream, "\n  1: int64 mod = ");
  if (number_div_response_has_mod(msg)) {
    z_dump_int64(stream, msg->mod);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int64 value = ");
  if (number_div_response_has_value(msg)) {
    z_dump_int64(stream, msg->value);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_insert_request *sset_insert_request_alloc (struct sset_insert_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_insert_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_insert_request_ialloc = 1;
  } else {
    msg->sset_insert_request_ialloc = 0;
  }

  z_memzero(msg->sset_insert_request_fields_bitmap, 1);
  msg->txn_id = 0;
  sset_insert_request_set_txn_id(msg);
  msg->allow_update = 0;
  sset_insert_request_set_allow_update(msg);
  z_bytes_ref_reset(&(msg->key));
  z_bytes_ref_reset(&(msg->value));
  return(msg);
}

void sset_insert_request_free (struct sset_insert_request *msg) {
   z_bytes_ref_release(&(msg->key));
   z_bytes_ref_release(&(msg->value));
  if (msg->sset_insert_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_insert_request, msg);
}

int sset_insert_request_parse (struct sset_insert_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_insert_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_insert_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int8 allow_update */
        if (Z_UNLIKELY(length > sizeof(int8_t))) return(-1);
        r = z_reader_decode_int8(reader, length, &(msg->allow_update));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_insert_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* bytes key */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->key));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_insert_request_fields_bitmap, 3);
        break;
      }

      case 4: { /* bytes value */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_insert_request_fields_bitmap, 4);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_insert_request_size (struct sset_insert_request *msg) {
  size_t size = 0;
  
  if (sset_insert_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (sset_insert_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (sset_insert_request_has_allow_update(msg)) {
    size_t length = z_int8_size(msg->allow_update);
    size += z_encoded_field_length(2, length) + length;
  }

  if (sset_insert_request_has_key(msg)) {
    size += z_encoded_field_length(3, msg->key.slice.size);
    size += msg->key.slice.size;
  }

  if (sset_insert_request_has_value(msg)) {
    size += z_encoded_field_length(4, msg->value.slice.size);
    size += msg->value.slice.size;
  }
  return(size);
}

int sset_insert_request_write (struct sset_insert_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_insert_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_insert_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (sset_insert_request_has_allow_update(msg)) {
    r = z_write_field_int8(buffer, 2, msg->allow_update);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (sset_insert_request_has_key(msg)) {
    r = z_write_field_bytes(buffer, 3, &(msg->key));
    if (Z_UNLIKELY(r)) return(-3);
  }

  if (sset_insert_request_has_value(msg)) {
    r = z_write_field_bytes(buffer, 4, &(msg->value));
    if (Z_UNLIKELY(r)) return(-4);
  }
  return(r);
}

void sset_insert_request_dump (FILE *stream, const struct sset_insert_request *msg) {
  fprintf(stream, "sset_insert_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (sset_insert_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (sset_insert_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int8 allow_update = ");
  if (sset_insert_request_has_allow_update(msg)) {
    z_dump_int8(stream, msg->allow_update);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: bytes key = ");
  if (sset_insert_request_has_key(msg)) {
    z_dump_bytes(stream, &(msg->key));
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  4: bytes value = ");
  if (sset_insert_request_has_value(msg)) {
    z_dump_bytes(stream, &(msg->value));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_insert_response *sset_insert_response_alloc (struct sset_insert_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_insert_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_insert_response_ialloc = 1;
  } else {
    msg->sset_insert_response_ialloc = 0;
  }

  z_memzero(msg->sset_insert_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void sset_insert_response_free (struct sset_insert_response *msg) {
   status_free(&(msg->status));
  if (msg->sset_insert_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_insert_response, msg);
}

int sset_insert_response_parse (struct sset_insert_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_insert_response_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_insert_response_size (struct sset_insert_response *msg) {
  size_t size = 0;
  
  if (sset_insert_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
  return(size);
}

int sset_insert_response_write (struct sset_insert_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_insert_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }
  return(r);
}

void sset_insert_response_dump (FILE *stream, const struct sset_insert_response *msg) {
  fprintf(stream, "sset_insert_response {");
  
  fprintf(stream, "\n}\n");
}

struct sset_update_request *sset_update_request_alloc (struct sset_update_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_update_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_update_request_ialloc = 1;
  } else {
    msg->sset_update_request_ialloc = 0;
  }

  z_memzero(msg->sset_update_request_fields_bitmap, 1);
  msg->txn_id = 0;
  sset_update_request_set_txn_id(msg);
  z_bytes_ref_reset(&(msg->key));
  z_bytes_ref_reset(&(msg->value));
  return(msg);
}

void sset_update_request_free (struct sset_update_request *msg) {
   z_bytes_ref_release(&(msg->key));
   z_bytes_ref_release(&(msg->value));
  if (msg->sset_update_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_update_request, msg);
}

int sset_update_request_parse (struct sset_update_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_update_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_update_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* bytes key */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->key));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_update_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* bytes value */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_update_request_fields_bitmap, 3);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_update_request_size (struct sset_update_request *msg) {
  size_t size = 0;
  
  if (sset_update_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (sset_update_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (sset_update_request_has_key(msg)) {
    size += z_encoded_field_length(2, msg->key.slice.size);
    size += msg->key.slice.size;
  }

  if (sset_update_request_has_value(msg)) {
    size += z_encoded_field_length(3, msg->value.slice.size);
    size += msg->value.slice.size;
  }
  return(size);
}

int sset_update_request_write (struct sset_update_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_update_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_update_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (sset_update_request_has_key(msg)) {
    r = z_write_field_bytes(buffer, 2, &(msg->key));
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (sset_update_request_has_value(msg)) {
    r = z_write_field_bytes(buffer, 3, &(msg->value));
    if (Z_UNLIKELY(r)) return(-3);
  }
  return(r);
}

void sset_update_request_dump (FILE *stream, const struct sset_update_request *msg) {
  fprintf(stream, "sset_update_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (sset_update_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (sset_update_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes key = ");
  if (sset_update_request_has_key(msg)) {
    z_dump_bytes(stream, &(msg->key));
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: bytes value = ");
  if (sset_update_request_has_value(msg)) {
    z_dump_bytes(stream, &(msg->value));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_update_response *sset_update_response_alloc (struct sset_update_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_update_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_update_response_ialloc = 1;
  } else {
    msg->sset_update_response_ialloc = 0;
  }

  z_memzero(msg->sset_update_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  z_bytes_ref_reset(&(msg->old_value));
  return(msg);
}

void sset_update_response_free (struct sset_update_response *msg) {
   status_free(&(msg->status));
   z_bytes_ref_release(&(msg->old_value));
  if (msg->sset_update_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_update_response, msg);
}

int sset_update_response_parse (struct sset_update_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_update_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* bytes old_value */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->old_value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_update_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_update_response_size (struct sset_update_response *msg) {
  size_t size = 0;
  
  if (sset_update_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (sset_update_response_has_old_value(msg)) {
    size += z_encoded_field_length(1, msg->old_value.slice.size);
    size += msg->old_value.slice.size;
  }
  return(size);
}

int sset_update_response_write (struct sset_update_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_update_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_update_response_has_old_value(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->old_value));
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void sset_update_response_dump (FILE *stream, const struct sset_update_response *msg) {
  fprintf(stream, "sset_update_response {");
  
  fprintf(stream, "\n  1: bytes old_value = ");
  if (sset_update_response_has_old_value(msg)) {
    z_dump_bytes(stream, &(msg->old_value));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_pop_request *sset_pop_request_alloc (struct sset_pop_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_pop_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_pop_request_ialloc = 1;
  } else {
    msg->sset_pop_request_ialloc = 0;
  }

  z_memzero(msg->sset_pop_request_fields_bitmap, 1);
  msg->txn_id = 0;
  sset_pop_request_set_txn_id(msg);
  z_bytes_ref_reset(&(msg->key));
  return(msg);
}

void sset_pop_request_free (struct sset_pop_request *msg) {
   z_bytes_ref_release(&(msg->key));
  if (msg->sset_pop_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_pop_request, msg);
}

int sset_pop_request_parse (struct sset_pop_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_pop_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_pop_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* bytes key */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->key));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_pop_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_pop_request_size (struct sset_pop_request *msg) {
  size_t size = 0;
  
  if (sset_pop_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (sset_pop_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (sset_pop_request_has_key(msg)) {
    size += z_encoded_field_length(2, msg->key.slice.size);
    size += msg->key.slice.size;
  }
  return(size);
}

int sset_pop_request_write (struct sset_pop_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_pop_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_pop_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (sset_pop_request_has_key(msg)) {
    r = z_write_field_bytes(buffer, 2, &(msg->key));
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void sset_pop_request_dump (FILE *stream, const struct sset_pop_request *msg) {
  fprintf(stream, "sset_pop_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (sset_pop_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (sset_pop_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes key = ");
  if (sset_pop_request_has_key(msg)) {
    z_dump_bytes(stream, &(msg->key));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_pop_response *sset_pop_response_alloc (struct sset_pop_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_pop_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_pop_response_ialloc = 1;
  } else {
    msg->sset_pop_response_ialloc = 0;
  }

  z_memzero(msg->sset_pop_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  z_bytes_ref_reset(&(msg->value));
  return(msg);
}

void sset_pop_response_free (struct sset_pop_response *msg) {
   status_free(&(msg->status));
   z_bytes_ref_release(&(msg->value));
  if (msg->sset_pop_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_pop_response, msg);
}

int sset_pop_response_parse (struct sset_pop_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_pop_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* bytes value */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_pop_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_pop_response_size (struct sset_pop_response *msg) {
  size_t size = 0;
  
  if (sset_pop_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (sset_pop_response_has_value(msg)) {
    size += z_encoded_field_length(1, msg->value.slice.size);
    size += msg->value.slice.size;
  }
  return(size);
}

int sset_pop_response_write (struct sset_pop_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_pop_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_pop_response_has_value(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->value));
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void sset_pop_response_dump (FILE *stream, const struct sset_pop_response *msg) {
  fprintf(stream, "sset_pop_response {");
  
  fprintf(stream, "\n  1: bytes value = ");
  if (sset_pop_response_has_value(msg)) {
    z_dump_bytes(stream, &(msg->value));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_get_request *sset_get_request_alloc (struct sset_get_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_get_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_get_request_ialloc = 1;
  } else {
    msg->sset_get_request_ialloc = 0;
  }

  z_memzero(msg->sset_get_request_fields_bitmap, 1);
  msg->txn_id = 0;
  sset_get_request_set_txn_id(msg);
  z_bytes_ref_reset(&(msg->key));
  return(msg);
}

void sset_get_request_free (struct sset_get_request *msg) {
   z_bytes_ref_release(&(msg->key));
  if (msg->sset_get_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_get_request, msg);
}

int sset_get_request_parse (struct sset_get_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_get_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_get_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* bytes key */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->key));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_get_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_get_request_size (struct sset_get_request *msg) {
  size_t size = 0;
  
  if (sset_get_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (sset_get_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (sset_get_request_has_key(msg)) {
    size += z_encoded_field_length(2, msg->key.slice.size);
    size += msg->key.slice.size;
  }
  return(size);
}

int sset_get_request_write (struct sset_get_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_get_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_get_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (sset_get_request_has_key(msg)) {
    r = z_write_field_bytes(buffer, 2, &(msg->key));
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void sset_get_request_dump (FILE *stream, const struct sset_get_request *msg) {
  fprintf(stream, "sset_get_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (sset_get_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (sset_get_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes key = ");
  if (sset_get_request_has_key(msg)) {
    z_dump_bytes(stream, &(msg->key));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_get_response *sset_get_response_alloc (struct sset_get_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_get_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_get_response_ialloc = 1;
  } else {
    msg->sset_get_response_ialloc = 0;
  }

  z_memzero(msg->sset_get_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  z_bytes_ref_reset(&(msg->value));
  return(msg);
}

void sset_get_response_free (struct sset_get_response *msg) {
   status_free(&(msg->status));
   z_bytes_ref_release(&(msg->value));
  if (msg->sset_get_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_get_response, msg);
}

int sset_get_response_parse (struct sset_get_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_get_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* bytes value */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->value));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_get_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_get_response_size (struct sset_get_response *msg) {
  size_t size = 0;
  
  if (sset_get_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (sset_get_response_has_value(msg)) {
    size += z_encoded_field_length(1, msg->value.slice.size);
    size += msg->value.slice.size;
  }
  return(size);
}

int sset_get_response_write (struct sset_get_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_get_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_get_response_has_value(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->value));
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void sset_get_response_dump (FILE *stream, const struct sset_get_response *msg) {
  fprintf(stream, "sset_get_response {");
  
  fprintf(stream, "\n  1: bytes value = ");
  if (sset_get_response_has_value(msg)) {
    z_dump_bytes(stream, &(msg->value));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_scan_request *sset_scan_request_alloc (struct sset_scan_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_scan_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_scan_request_ialloc = 1;
  } else {
    msg->sset_scan_request_ialloc = 0;
  }

  z_memzero(msg->sset_scan_request_fields_bitmap, 1);
  msg->txn_id = 0;
  sset_scan_request_set_txn_id(msg);
  z_bytes_ref_reset(&(msg->key));
  msg->include_key = 1;
  sset_scan_request_set_include_key(msg);
  return(msg);
}

void sset_scan_request_free (struct sset_scan_request *msg) {
   z_bytes_ref_release(&(msg->key));
  if (msg->sset_scan_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_scan_request, msg);
}

int sset_scan_request_parse (struct sset_scan_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* uint32 count */
        if (Z_UNLIKELY(length > sizeof(uint32_t))) return(-1);
        r = z_reader_decode_uint32(reader, length, &(msg->count));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* bytes key */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->key));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_request_fields_bitmap, 3);
        break;
      }

      case 4: { /* int8 include_key */
        if (Z_UNLIKELY(length > sizeof(int8_t))) return(-1);
        r = z_reader_decode_int8(reader, length, &(msg->include_key));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_request_fields_bitmap, 4);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_scan_request_size (struct sset_scan_request *msg) {
  size_t size = 0;
  
  if (sset_scan_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (sset_scan_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (sset_scan_request_has_count(msg)) {
    size_t length = z_uint32_size(msg->count);
    size += z_encoded_field_length(2, length) + length;
  }

  if (sset_scan_request_has_key(msg)) {
    size += z_encoded_field_length(3, msg->key.slice.size);
    size += msg->key.slice.size;
  }

  if (sset_scan_request_has_include_key(msg)) {
    size_t length = z_int8_size(msg->include_key);
    size += z_encoded_field_length(4, length) + length;
  }
  return(size);
}

int sset_scan_request_write (struct sset_scan_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_scan_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_scan_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (sset_scan_request_has_count(msg)) {
    r = z_write_field_uint32(buffer, 2, msg->count);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (sset_scan_request_has_key(msg)) {
    r = z_write_field_bytes(buffer, 3, &(msg->key));
    if (Z_UNLIKELY(r)) return(-3);
  }

  if (sset_scan_request_has_include_key(msg)) {
    r = z_write_field_int8(buffer, 4, msg->include_key);
    if (Z_UNLIKELY(r)) return(-4);
  }
  return(r);
}

void sset_scan_request_dump (FILE *stream, const struct sset_scan_request *msg) {
  fprintf(stream, "sset_scan_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (sset_scan_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (sset_scan_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: uint32 count = ");
  if (sset_scan_request_has_count(msg)) {
    z_dump_uint32(stream, msg->count);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: bytes key = ");
  if (sset_scan_request_has_key(msg)) {
    z_dump_bytes(stream, &(msg->key));
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  4: int8 include_key = ");
  if (sset_scan_request_has_include_key(msg)) {
    z_dump_int8(stream, msg->include_key);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct sset_scan_response *sset_scan_response_alloc (struct sset_scan_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct sset_scan_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->sset_scan_response_ialloc = 1;
  } else {
    msg->sset_scan_response_ialloc = 0;
  }

  z_memzero(msg->sset_scan_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  z_array_open(&(msg->keys), sizeof(z_bytes_ref_t));
  z_array_open(&(msg->values), sizeof(z_bytes_ref_t));
  return(msg);
}

void sset_scan_response_free (struct sset_scan_response *msg) {
   status_free(&(msg->status));

  do {
    size_t i;
    for (i = 0; i < msg->keys.count; ++i) {
      z_bytes_ref_t *value = z_array_get(&(msg->keys), z_bytes_ref_t, i);
      z_bytes_ref_release(value);
    }
  } while (0);
  z_array_close(&(msg->keys));

  do {
    size_t i;
    for (i = 0; i < msg->values.count; ++i) {
      z_bytes_ref_t *value = z_array_get(&(msg->values), z_bytes_ref_t, i);
      z_bytes_ref_release(value);
    }
  } while (0);
  z_array_close(&(msg->values));
  if (msg->sset_scan_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct sset_scan_response, msg);
}

int sset_scan_response_parse (struct sset_scan_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* list[bytes] keys */
        z_bytes_ref_t keys;
        if (Z_UNLIKELY(length > sizeof(z_bytes_ref_t))) return(-1);
        r = z_reader_decode_bytes(reader, length, &keys);
        if (Z_UNLIKELY(r)) return(-1);
        r = z_array_push_back_copy(&(msg->keys), &keys);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_response_fields_bitmap, 1);
        break;
      }

      case 2: { /* list[bytes] values */
        z_bytes_ref_t values;
        if (Z_UNLIKELY(length > sizeof(z_bytes_ref_t))) return(-1);
        r = z_reader_decode_bytes(reader, length, &values);
        if (Z_UNLIKELY(r)) return(-1);
        r = z_array_push_back_copy(&(msg->values), &values);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->sset_scan_response_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t sset_scan_response_size (struct sset_scan_response *msg) {
  size_t size = 0;
  
  if (sset_scan_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
/* TODO keys */
/* TODO values */
  return(size);
}

int sset_scan_response_write (struct sset_scan_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (sset_scan_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (sset_scan_response_has_keys(msg)) {
    size_t i;
    for (i = 0; i < msg->keys.count; ++i) {
      const z_bytes_ref_t *value = z_array_get(&(msg->keys), z_bytes_ref_t, i);
      r = z_write_field_bytes(buffer, 1, value);
      if (Z_UNLIKELY(r)) return(-1);
    }
  }

  if (sset_scan_response_has_values(msg)) {
    size_t i;
    for (i = 0; i < msg->values.count; ++i) {
      const z_bytes_ref_t *value = z_array_get(&(msg->values), z_bytes_ref_t, i);
      r = z_write_field_bytes(buffer, 2, value);
      if (Z_UNLIKELY(r)) return(-2);
    }
  }
  return(r);
}

void sset_scan_response_dump (FILE *stream, const struct sset_scan_response *msg) {
  fprintf(stream, "sset_scan_response {");
  
  fprintf(stream, "\n  1: bytes keys = ");
  if (sset_scan_response_has_keys(msg)) {

    size_t i;
    for (i = 0; i < msg->keys.count; ++i) {
      const z_bytes_ref_t *value = z_array_get(&(msg->keys), z_bytes_ref_t, i);
      fprintf(stream, "[%zu]", i);
      z_dump_bytes(stream, value);
    }

  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes values = ");
  if (sset_scan_response_has_values(msg)) {

    size_t i;
    for (i = 0; i < msg->values.count; ++i) {
      const z_bytes_ref_t *value = z_array_get(&(msg->values), z_bytes_ref_t, i);
      fprintf(stream, "[%zu]", i);
      z_dump_bytes(stream, value);
    }

  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_append_request *flow_append_request_alloc (struct flow_append_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_append_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_append_request_ialloc = 1;
  } else {
    msg->flow_append_request_ialloc = 0;
  }

  z_memzero(msg->flow_append_request_fields_bitmap, 1);
  msg->txn_id = 0;
  flow_append_request_set_txn_id(msg);
  z_bytes_ref_reset(&(msg->data));
  return(msg);
}

void flow_append_request_free (struct flow_append_request *msg) {
   z_bytes_ref_release(&(msg->data));
  if (msg->flow_append_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_append_request, msg);
}

int flow_append_request_parse (struct flow_append_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_append_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_append_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* bytes data */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->data));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_append_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_append_request_size (struct flow_append_request *msg) {
  size_t size = 0;
  
  if (flow_append_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (flow_append_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (flow_append_request_has_data(msg)) {
    size += z_encoded_field_length(2, msg->data.slice.size);
    size += msg->data.slice.size;
  }
  return(size);
}

int flow_append_request_write (struct flow_append_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_append_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_append_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (flow_append_request_has_data(msg)) {
    r = z_write_field_bytes(buffer, 2, &(msg->data));
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void flow_append_request_dump (FILE *stream, const struct flow_append_request *msg) {
  fprintf(stream, "flow_append_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (flow_append_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (flow_append_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: bytes data = ");
  if (flow_append_request_has_data(msg)) {
    z_dump_bytes(stream, &(msg->data));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_append_response *flow_append_response_alloc (struct flow_append_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_append_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_append_response_ialloc = 1;
  } else {
    msg->flow_append_response_ialloc = 0;
  }

  z_memzero(msg->flow_append_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void flow_append_response_free (struct flow_append_response *msg) {
   status_free(&(msg->status));
  if (msg->flow_append_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_append_response, msg);
}

int flow_append_response_parse (struct flow_append_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_append_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_append_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_append_response_size (struct flow_append_response *msg) {
  size_t size = 0;
  
  if (flow_append_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (flow_append_response_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int flow_append_response_write (struct flow_append_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_append_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_append_response_has_size(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->size);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void flow_append_response_dump (FILE *stream, const struct flow_append_response *msg) {
  fprintf(stream, "flow_append_response {");
  
  fprintf(stream, "\n  1: uint64 size = ");
  if (flow_append_response_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_inject_request *flow_inject_request_alloc (struct flow_inject_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_inject_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_inject_request_ialloc = 1;
  } else {
    msg->flow_inject_request_ialloc = 0;
  }

  z_memzero(msg->flow_inject_request_fields_bitmap, 1);
  msg->txn_id = 0;
  flow_inject_request_set_txn_id(msg);
  z_bytes_ref_reset(&(msg->data));
  return(msg);
}

void flow_inject_request_free (struct flow_inject_request *msg) {
   z_bytes_ref_release(&(msg->data));
  if (msg->flow_inject_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_inject_request, msg);
}

int flow_inject_request_parse (struct flow_inject_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_inject_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_inject_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* uint64 offset */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->offset));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_inject_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* bytes data */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->data));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_inject_request_fields_bitmap, 3);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_inject_request_size (struct flow_inject_request *msg) {
  size_t size = 0;
  
  if (flow_inject_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (flow_inject_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (flow_inject_request_has_offset(msg)) {
    size_t length = z_uint64_size(msg->offset);
    size += z_encoded_field_length(2, length) + length;
  }

  if (flow_inject_request_has_data(msg)) {
    size += z_encoded_field_length(3, msg->data.slice.size);
    size += msg->data.slice.size;
  }
  return(size);
}

int flow_inject_request_write (struct flow_inject_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_inject_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_inject_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (flow_inject_request_has_offset(msg)) {
    r = z_write_field_uint64(buffer, 2, msg->offset);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (flow_inject_request_has_data(msg)) {
    r = z_write_field_bytes(buffer, 3, &(msg->data));
    if (Z_UNLIKELY(r)) return(-3);
  }
  return(r);
}

void flow_inject_request_dump (FILE *stream, const struct flow_inject_request *msg) {
  fprintf(stream, "flow_inject_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (flow_inject_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (flow_inject_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: uint64 offset = ");
  if (flow_inject_request_has_offset(msg)) {
    z_dump_uint64(stream, msg->offset);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: bytes data = ");
  if (flow_inject_request_has_data(msg)) {
    z_dump_bytes(stream, &(msg->data));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_inject_response *flow_inject_response_alloc (struct flow_inject_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_inject_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_inject_response_ialloc = 1;
  } else {
    msg->flow_inject_response_ialloc = 0;
  }

  z_memzero(msg->flow_inject_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void flow_inject_response_free (struct flow_inject_response *msg) {
   status_free(&(msg->status));
  if (msg->flow_inject_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_inject_response, msg);
}

int flow_inject_response_parse (struct flow_inject_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_inject_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_inject_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_inject_response_size (struct flow_inject_response *msg) {
  size_t size = 0;
  
  if (flow_inject_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (flow_inject_response_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int flow_inject_response_write (struct flow_inject_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_inject_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_inject_response_has_size(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->size);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void flow_inject_response_dump (FILE *stream, const struct flow_inject_response *msg) {
  fprintf(stream, "flow_inject_response {");
  
  fprintf(stream, "\n  1: uint64 size = ");
  if (flow_inject_response_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_write_request *flow_write_request_alloc (struct flow_write_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_write_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_write_request_ialloc = 1;
  } else {
    msg->flow_write_request_ialloc = 0;
  }

  z_memzero(msg->flow_write_request_fields_bitmap, 1);
  msg->txn_id = 0;
  flow_write_request_set_txn_id(msg);
  z_bytes_ref_reset(&(msg->data));
  return(msg);
}

void flow_write_request_free (struct flow_write_request *msg) {
   z_bytes_ref_release(&(msg->data));
  if (msg->flow_write_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_write_request, msg);
}

int flow_write_request_parse (struct flow_write_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_write_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_write_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* uint64 offset */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->offset));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_write_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* bytes data */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->data));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_write_request_fields_bitmap, 3);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_write_request_size (struct flow_write_request *msg) {
  size_t size = 0;
  
  if (flow_write_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (flow_write_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (flow_write_request_has_offset(msg)) {
    size_t length = z_uint64_size(msg->offset);
    size += z_encoded_field_length(2, length) + length;
  }

  if (flow_write_request_has_data(msg)) {
    size += z_encoded_field_length(3, msg->data.slice.size);
    size += msg->data.slice.size;
  }
  return(size);
}

int flow_write_request_write (struct flow_write_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_write_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_write_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (flow_write_request_has_offset(msg)) {
    r = z_write_field_uint64(buffer, 2, msg->offset);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (flow_write_request_has_data(msg)) {
    r = z_write_field_bytes(buffer, 3, &(msg->data));
    if (Z_UNLIKELY(r)) return(-3);
  }
  return(r);
}

void flow_write_request_dump (FILE *stream, const struct flow_write_request *msg) {
  fprintf(stream, "flow_write_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (flow_write_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (flow_write_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: uint64 offset = ");
  if (flow_write_request_has_offset(msg)) {
    z_dump_uint64(stream, msg->offset);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: bytes data = ");
  if (flow_write_request_has_data(msg)) {
    z_dump_bytes(stream, &(msg->data));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_write_response *flow_write_response_alloc (struct flow_write_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_write_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_write_response_ialloc = 1;
  } else {
    msg->flow_write_response_ialloc = 0;
  }

  z_memzero(msg->flow_write_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void flow_write_response_free (struct flow_write_response *msg) {
   status_free(&(msg->status));
  if (msg->flow_write_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_write_response, msg);
}

int flow_write_response_parse (struct flow_write_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_write_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_write_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_write_response_size (struct flow_write_response *msg) {
  size_t size = 0;
  
  if (flow_write_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (flow_write_response_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int flow_write_response_write (struct flow_write_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_write_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_write_response_has_size(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->size);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void flow_write_response_dump (FILE *stream, const struct flow_write_response *msg) {
  fprintf(stream, "flow_write_response {");
  
  fprintf(stream, "\n  1: uint64 size = ");
  if (flow_write_response_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_remove_request *flow_remove_request_alloc (struct flow_remove_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_remove_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_remove_request_ialloc = 1;
  } else {
    msg->flow_remove_request_ialloc = 0;
  }

  z_memzero(msg->flow_remove_request_fields_bitmap, 1);
  msg->txn_id = 0;
  flow_remove_request_set_txn_id(msg);
  return(msg);
}

void flow_remove_request_free (struct flow_remove_request *msg) {

  if (msg->flow_remove_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_remove_request, msg);
}

int flow_remove_request_parse (struct flow_remove_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_remove_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_remove_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* uint64 offset */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->offset));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_remove_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_remove_request_fields_bitmap, 3);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_remove_request_size (struct flow_remove_request *msg) {
  size_t size = 0;
  
  if (flow_remove_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (flow_remove_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (flow_remove_request_has_offset(msg)) {
    size_t length = z_uint64_size(msg->offset);
    size += z_encoded_field_length(2, length) + length;
  }

  if (flow_remove_request_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(3, length) + length;
  }
  return(size);
}

int flow_remove_request_write (struct flow_remove_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_remove_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_remove_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (flow_remove_request_has_offset(msg)) {
    r = z_write_field_uint64(buffer, 2, msg->offset);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (flow_remove_request_has_size(msg)) {
    r = z_write_field_uint64(buffer, 3, msg->size);
    if (Z_UNLIKELY(r)) return(-3);
  }
  return(r);
}

void flow_remove_request_dump (FILE *stream, const struct flow_remove_request *msg) {
  fprintf(stream, "flow_remove_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (flow_remove_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (flow_remove_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: uint64 offset = ");
  if (flow_remove_request_has_offset(msg)) {
    z_dump_uint64(stream, msg->offset);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: uint64 size = ");
  if (flow_remove_request_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_remove_response *flow_remove_response_alloc (struct flow_remove_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_remove_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_remove_response_ialloc = 1;
  } else {
    msg->flow_remove_response_ialloc = 0;
  }

  z_memzero(msg->flow_remove_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void flow_remove_response_free (struct flow_remove_response *msg) {
   status_free(&(msg->status));
  if (msg->flow_remove_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_remove_response, msg);
}

int flow_remove_response_parse (struct flow_remove_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_remove_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_remove_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_remove_response_size (struct flow_remove_response *msg) {
  size_t size = 0;
  
  if (flow_remove_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (flow_remove_response_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int flow_remove_response_write (struct flow_remove_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_remove_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_remove_response_has_size(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->size);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void flow_remove_response_dump (FILE *stream, const struct flow_remove_response *msg) {
  fprintf(stream, "flow_remove_response {");
  
  fprintf(stream, "\n  1: uint64 size = ");
  if (flow_remove_response_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_truncate_request *flow_truncate_request_alloc (struct flow_truncate_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_truncate_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_truncate_request_ialloc = 1;
  } else {
    msg->flow_truncate_request_ialloc = 0;
  }

  z_memzero(msg->flow_truncate_request_fields_bitmap, 1);
  msg->txn_id = 0;
  flow_truncate_request_set_txn_id(msg);
  return(msg);
}

void flow_truncate_request_free (struct flow_truncate_request *msg) {

  if (msg->flow_truncate_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_truncate_request, msg);
}

int flow_truncate_request_parse (struct flow_truncate_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_truncate_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_truncate_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_truncate_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_truncate_request_size (struct flow_truncate_request *msg) {
  size_t size = 0;
  
  if (flow_truncate_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (flow_truncate_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (flow_truncate_request_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(2, length) + length;
  }
  return(size);
}

int flow_truncate_request_write (struct flow_truncate_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_truncate_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_truncate_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (flow_truncate_request_has_size(msg)) {
    r = z_write_field_uint64(buffer, 2, msg->size);
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void flow_truncate_request_dump (FILE *stream, const struct flow_truncate_request *msg) {
  fprintf(stream, "flow_truncate_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (flow_truncate_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (flow_truncate_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: uint64 size = ");
  if (flow_truncate_request_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_truncate_response *flow_truncate_response_alloc (struct flow_truncate_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_truncate_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_truncate_response_ialloc = 1;
  } else {
    msg->flow_truncate_response_ialloc = 0;
  }

  z_memzero(msg->flow_truncate_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void flow_truncate_response_free (struct flow_truncate_response *msg) {
   status_free(&(msg->status));
  if (msg->flow_truncate_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_truncate_response, msg);
}

int flow_truncate_response_parse (struct flow_truncate_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_truncate_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_truncate_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_truncate_response_size (struct flow_truncate_response *msg) {
  size_t size = 0;
  
  if (flow_truncate_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (flow_truncate_response_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int flow_truncate_response_write (struct flow_truncate_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_truncate_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_truncate_response_has_size(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->size);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void flow_truncate_response_dump (FILE *stream, const struct flow_truncate_response *msg) {
  fprintf(stream, "flow_truncate_response {");
  
  fprintf(stream, "\n  1: uint64 size = ");
  if (flow_truncate_response_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_read_request *flow_read_request_alloc (struct flow_read_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_read_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_read_request_ialloc = 1;
  } else {
    msg->flow_read_request_ialloc = 0;
  }

  z_memzero(msg->flow_read_request_fields_bitmap, 1);
  msg->txn_id = 0;
  flow_read_request_set_txn_id(msg);
  return(msg);
}

void flow_read_request_free (struct flow_read_request *msg) {

  if (msg->flow_read_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_read_request, msg);
}

int flow_read_request_parse (struct flow_read_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_read_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_read_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* uint64 offset */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->offset));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_read_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* uint64 size */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->size));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_read_request_fields_bitmap, 3);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_read_request_size (struct flow_read_request *msg) {
  size_t size = 0;
  
  if (flow_read_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (flow_read_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (flow_read_request_has_offset(msg)) {
    size_t length = z_uint64_size(msg->offset);
    size += z_encoded_field_length(2, length) + length;
  }

  if (flow_read_request_has_size(msg)) {
    size_t length = z_uint64_size(msg->size);
    size += z_encoded_field_length(3, length) + length;
  }
  return(size);
}

int flow_read_request_write (struct flow_read_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_read_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_read_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (flow_read_request_has_offset(msg)) {
    r = z_write_field_uint64(buffer, 2, msg->offset);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (flow_read_request_has_size(msg)) {
    r = z_write_field_uint64(buffer, 3, msg->size);
    if (Z_UNLIKELY(r)) return(-3);
  }
  return(r);
}

void flow_read_request_dump (FILE *stream, const struct flow_read_request *msg) {
  fprintf(stream, "flow_read_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (flow_read_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (flow_read_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: uint64 offset = ");
  if (flow_read_request_has_offset(msg)) {
    z_dump_uint64(stream, msg->offset);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: uint64 size = ");
  if (flow_read_request_has_size(msg)) {
    z_dump_uint64(stream, msg->size);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct flow_read_response *flow_read_response_alloc (struct flow_read_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct flow_read_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->flow_read_response_ialloc = 1;
  } else {
    msg->flow_read_response_ialloc = 0;
  }

  z_memzero(msg->flow_read_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  z_bytes_ref_reset(&(msg->data));
  return(msg);
}

void flow_read_response_free (struct flow_read_response *msg) {
   status_free(&(msg->status));
   z_bytes_ref_release(&(msg->data));
  if (msg->flow_read_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct flow_read_response, msg);
}

int flow_read_response_parse (struct flow_read_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_read_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* bytes data */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->data));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->flow_read_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t flow_read_response_size (struct flow_read_response *msg) {
  size_t size = 0;
  
  if (flow_read_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (flow_read_response_has_data(msg)) {
    size += z_encoded_field_length(1, msg->data.slice.size);
    size += msg->data.slice.size;
  }
  return(size);
}

int flow_read_response_write (struct flow_read_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (flow_read_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (flow_read_response_has_data(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->data));
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void flow_read_response_dump (FILE *stream, const struct flow_read_response *msg) {
  fprintf(stream, "flow_read_response {");
  
  fprintf(stream, "\n  1: bytes data = ");
  if (flow_read_response_has_data(msg)) {
    z_dump_bytes(stream, &(msg->data));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct deque_push_request *deque_push_request_alloc (struct deque_push_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct deque_push_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->deque_push_request_ialloc = 1;
  } else {
    msg->deque_push_request_ialloc = 0;
  }

  z_memzero(msg->deque_push_request_fields_bitmap, 1);
  msg->txn_id = 0;
  deque_push_request_set_txn_id(msg);
  msg->front = 0;
  deque_push_request_set_front(msg);
  z_bytes_ref_reset(&(msg->data));
  return(msg);
}

void deque_push_request_free (struct deque_push_request *msg) {
   z_bytes_ref_release(&(msg->data));
  if (msg->deque_push_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct deque_push_request, msg);
}

int deque_push_request_parse (struct deque_push_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_push_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_push_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int8 front */
        if (Z_UNLIKELY(length > sizeof(int8_t))) return(-1);
        r = z_reader_decode_int8(reader, length, &(msg->front));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_push_request_fields_bitmap, 2);
        break;
      }

      case 3: { /* bytes data */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->data));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_push_request_fields_bitmap, 3);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t deque_push_request_size (struct deque_push_request *msg) {
  size_t size = 0;
  
  if (deque_push_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (deque_push_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (deque_push_request_has_front(msg)) {
    size_t length = z_int8_size(msg->front);
    size += z_encoded_field_length(2, length) + length;
  }

  if (deque_push_request_has_data(msg)) {
    size += z_encoded_field_length(3, msg->data.slice.size);
    size += msg->data.slice.size;
  }
  return(size);
}

int deque_push_request_write (struct deque_push_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (deque_push_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (deque_push_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (deque_push_request_has_front(msg)) {
    r = z_write_field_int8(buffer, 2, msg->front);
    if (Z_UNLIKELY(r)) return(-2);
  }

  if (deque_push_request_has_data(msg)) {
    r = z_write_field_bytes(buffer, 3, &(msg->data));
    if (Z_UNLIKELY(r)) return(-3);
  }
  return(r);
}

void deque_push_request_dump (FILE *stream, const struct deque_push_request *msg) {
  fprintf(stream, "deque_push_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (deque_push_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (deque_push_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int8 front = ");
  if (deque_push_request_has_front(msg)) {
    z_dump_int8(stream, msg->front);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  3: bytes data = ");
  if (deque_push_request_has_data(msg)) {
    z_dump_bytes(stream, &(msg->data));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct deque_push_response *deque_push_response_alloc (struct deque_push_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct deque_push_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->deque_push_response_ialloc = 1;
  } else {
    msg->deque_push_response_ialloc = 0;
  }

  z_memzero(msg->deque_push_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  return(msg);
}

void deque_push_response_free (struct deque_push_response *msg) {
   status_free(&(msg->status));
  if (msg->deque_push_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct deque_push_response, msg);
}

int deque_push_response_parse (struct deque_push_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_push_response_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t deque_push_response_size (struct deque_push_response *msg) {
  size_t size = 0;
  
  if (deque_push_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }
  return(size);
}

int deque_push_response_write (struct deque_push_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (deque_push_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }
  return(r);
}

void deque_push_response_dump (FILE *stream, const struct deque_push_response *msg) {
  fprintf(stream, "deque_push_response {");
  
  fprintf(stream, "\n}\n");
}

struct deque_pop_request *deque_pop_request_alloc (struct deque_pop_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct deque_pop_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->deque_pop_request_ialloc = 1;
  } else {
    msg->deque_pop_request_ialloc = 0;
  }

  z_memzero(msg->deque_pop_request_fields_bitmap, 1);
  msg->txn_id = 0;
  deque_pop_request_set_txn_id(msg);
  msg->front = 1;
  deque_pop_request_set_front(msg);
  return(msg);
}

void deque_pop_request_free (struct deque_pop_request *msg) {

  if (msg->deque_pop_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct deque_pop_request, msg);
}

int deque_pop_request_parse (struct deque_pop_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* uint64 txn_id */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->txn_id));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_pop_request_fields_bitmap, 0);
        break;
      }

      case 1: { /* uint64 oid */
        if (Z_UNLIKELY(length > sizeof(uint64_t))) return(-1);
        r = z_reader_decode_uint64(reader, length, &(msg->oid));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_pop_request_fields_bitmap, 1);
        break;
      }

      case 2: { /* int8 front */
        if (Z_UNLIKELY(length > sizeof(int8_t))) return(-1);
        r = z_reader_decode_int8(reader, length, &(msg->front));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_pop_request_fields_bitmap, 2);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t deque_pop_request_size (struct deque_pop_request *msg) {
  size_t size = 0;
  
  if (deque_pop_request_has_txn_id(msg)) {
    size_t length = z_uint64_size(msg->txn_id);
    size += z_encoded_field_length(0, length) + length;
  }

  if (deque_pop_request_has_oid(msg)) {
    size_t length = z_uint64_size(msg->oid);
    size += z_encoded_field_length(1, length) + length;
  }

  if (deque_pop_request_has_front(msg)) {
    size_t length = z_int8_size(msg->front);
    size += z_encoded_field_length(2, length) + length;
  }
  return(size);
}

int deque_pop_request_write (struct deque_pop_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (deque_pop_request_has_txn_id(msg)) {
    r = z_write_field_uint64(buffer, 0, msg->txn_id);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (deque_pop_request_has_oid(msg)) {
    r = z_write_field_uint64(buffer, 1, msg->oid);
    if (Z_UNLIKELY(r)) return(-1);
  }

  if (deque_pop_request_has_front(msg)) {
    r = z_write_field_int8(buffer, 2, msg->front);
    if (Z_UNLIKELY(r)) return(-2);
  }
  return(r);
}

void deque_pop_request_dump (FILE *stream, const struct deque_pop_request *msg) {
  fprintf(stream, "deque_pop_request {");
  
  fprintf(stream, "\n  0: uint64 txn_id = ");
  if (deque_pop_request_has_txn_id(msg)) {
    z_dump_uint64(stream, msg->txn_id);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  1: uint64 oid = ");
  if (deque_pop_request_has_oid(msg)) {
    z_dump_uint64(stream, msg->oid);
  } else {
    fprintf(stream, "MISSING");
  }

  fprintf(stream, "\n  2: int8 front = ");
  if (deque_pop_request_has_front(msg)) {
    z_dump_int8(stream, msg->front);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct deque_pop_response *deque_pop_response_alloc (struct deque_pop_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct deque_pop_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->deque_pop_response_ialloc = 1;
  } else {
    msg->deque_pop_response_ialloc = 0;
  }

  z_memzero(msg->deque_pop_response_fields_bitmap, 1);
  status_alloc(&(msg->status));
  z_bytes_ref_reset(&(msg->data));
  return(msg);
}

void deque_pop_response_free (struct deque_pop_response *msg) {
   status_free(&(msg->status));
   z_bytes_ref_release(&(msg->data));
  if (msg->deque_pop_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct deque_pop_response, msg);
}

int deque_pop_response_parse (struct deque_pop_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 0: { /* status status */
        r = status_parse(&(msg->status), reader, length);
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_pop_response_fields_bitmap, 0);
        break;
      }

      case 1: { /* bytes data */
        if (Z_UNLIKELY(length > 1024)) return(-1);
        r = z_reader_decode_bytes(reader, length, &(msg->data));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->deque_pop_response_fields_bitmap, 1);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t deque_pop_response_size (struct deque_pop_response *msg) {
  size_t size = 0;
  
  if (deque_pop_response_has_status(msg)) {
    size += status_size(&(msg->status));
  }

  if (deque_pop_response_has_data(msg)) {
    size += z_encoded_field_length(1, msg->data.slice.size);
    size += msg->data.slice.size;
  }
  return(size);
}

int deque_pop_response_write (struct deque_pop_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (deque_pop_response_has_status(msg)) {
    size_t size = status_size(&(msg->status));
    z_write_field(buffer, 0, size);
    r = status_write(&(msg->status), buffer);
    if (Z_UNLIKELY(r)) return(-0);
  }

  if (deque_pop_response_has_data(msg)) {
    r = z_write_field_bytes(buffer, 1, &(msg->data));
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void deque_pop_response_dump (FILE *stream, const struct deque_pop_response *msg) {
  fprintf(stream, "deque_pop_response {");
  
  fprintf(stream, "\n  1: bytes data = ");
  if (deque_pop_response_has_data(msg)) {
    z_dump_bytes(stream, &(msg->data));
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct server_ping_request *server_ping_request_alloc (struct server_ping_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_ping_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_ping_request_ialloc = 1;
  } else {
    msg->server_ping_request_ialloc = 0;
  }

  z_memzero(msg->server_ping_request_fields_bitmap, 0);

  return(msg);
}

void server_ping_request_free (struct server_ping_request *msg) {

  if (msg->server_ping_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_ping_request, msg);
}

int server_ping_request_parse (struct server_ping_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_ping_request_size (struct server_ping_request *msg) {
  size_t size = 0;
  
  return(size);
}

int server_ping_request_write (struct server_ping_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void server_ping_request_dump (FILE *stream, const struct server_ping_request *msg) {
  fprintf(stream, "server_ping_request {");
  
  fprintf(stream, "\n}\n");
}

struct server_ping_response *server_ping_response_alloc (struct server_ping_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_ping_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_ping_response_ialloc = 1;
  } else {
    msg->server_ping_response_ialloc = 0;
  }

  z_memzero(msg->server_ping_response_fields_bitmap, 0);

  return(msg);
}

void server_ping_response_free (struct server_ping_response *msg) {

  if (msg->server_ping_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_ping_response, msg);
}

int server_ping_response_parse (struct server_ping_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_ping_response_size (struct server_ping_response *msg) {
  size_t size = 0;
  
  return(size);
}

int server_ping_response_write (struct server_ping_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void server_ping_response_dump (FILE *stream, const struct server_ping_response *msg) {
  fprintf(stream, "server_ping_response {");
  
  fprintf(stream, "\n}\n");
}

struct server_info_request *server_info_request_alloc (struct server_info_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_info_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_info_request_ialloc = 1;
  } else {
    msg->server_info_request_ialloc = 0;
  }

  z_memzero(msg->server_info_request_fields_bitmap, 0);

  return(msg);
}

void server_info_request_free (struct server_info_request *msg) {

  if (msg->server_info_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_info_request, msg);
}

int server_info_request_parse (struct server_info_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_info_request_size (struct server_info_request *msg) {
  size_t size = 0;
  
  return(size);
}

int server_info_request_write (struct server_info_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void server_info_request_dump (FILE *stream, const struct server_info_request *msg) {
  fprintf(stream, "server_info_request {");
  
  fprintf(stream, "\n}\n");
}

struct server_info_response *server_info_response_alloc (struct server_info_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_info_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_info_response_ialloc = 1;
  } else {
    msg->server_info_response_ialloc = 0;
  }

  z_memzero(msg->server_info_response_fields_bitmap, 0);

  return(msg);
}

void server_info_response_free (struct server_info_response *msg) {

  if (msg->server_info_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_info_response, msg);
}

int server_info_response_parse (struct server_info_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_info_response_size (struct server_info_response *msg) {
  size_t size = 0;
  
  return(size);
}

int server_info_response_write (struct server_info_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void server_info_response_dump (FILE *stream, const struct server_info_response *msg) {
  fprintf(stream, "server_info_response {");
  
  fprintf(stream, "\n}\n");
}

struct server_quit_request *server_quit_request_alloc (struct server_quit_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_quit_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_quit_request_ialloc = 1;
  } else {
    msg->server_quit_request_ialloc = 0;
  }

  z_memzero(msg->server_quit_request_fields_bitmap, 0);

  return(msg);
}

void server_quit_request_free (struct server_quit_request *msg) {

  if (msg->server_quit_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_quit_request, msg);
}

int server_quit_request_parse (struct server_quit_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_quit_request_size (struct server_quit_request *msg) {
  size_t size = 0;
  
  return(size);
}

int server_quit_request_write (struct server_quit_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void server_quit_request_dump (FILE *stream, const struct server_quit_request *msg) {
  fprintf(stream, "server_quit_request {");
  
  fprintf(stream, "\n}\n");
}

struct server_quit_response *server_quit_response_alloc (struct server_quit_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_quit_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_quit_response_ialloc = 1;
  } else {
    msg->server_quit_response_ialloc = 0;
  }

  z_memzero(msg->server_quit_response_fields_bitmap, 0);

  return(msg);
}

void server_quit_response_free (struct server_quit_response *msg) {

  if (msg->server_quit_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_quit_response, msg);
}

int server_quit_response_parse (struct server_quit_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_quit_response_size (struct server_quit_response *msg) {
  size_t size = 0;
  
  return(size);
}

int server_quit_response_write (struct server_quit_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void server_quit_response_dump (FILE *stream, const struct server_quit_response *msg) {
  fprintf(stream, "server_quit_response {");
  
  fprintf(stream, "\n}\n");
}

struct server_debug_request *server_debug_request_alloc (struct server_debug_request *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_debug_request);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_debug_request_ialloc = 1;
  } else {
    msg->server_debug_request_ialloc = 0;
  }

  z_memzero(msg->server_debug_request_fields_bitmap, 1);

  return(msg);
}

void server_debug_request_free (struct server_debug_request *msg) {

  if (msg->server_debug_request_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_debug_request, msg);
}

int server_debug_request_parse (struct server_debug_request *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      
      case 1: { /* uint8 log_level */
        if (Z_UNLIKELY(length > sizeof(uint8_t))) return(-1);
        r = z_reader_decode_uint8(reader, length, &(msg->log_level));
        if (Z_UNLIKELY(r)) return(-1);
        z_bitmap_set(msg->server_debug_request_fields_bitmap, 0);
        break;
      }

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_debug_request_size (struct server_debug_request *msg) {
  size_t size = 0;
  
  if (server_debug_request_has_log_level(msg)) {
    size_t length = z_uint8_size(msg->log_level);
    size += z_encoded_field_length(1, length) + length;
  }
  return(size);
}

int server_debug_request_write (struct server_debug_request *msg, z_buffer_t *buffer) {
  int r = 0;
  
  if (server_debug_request_has_log_level(msg)) {
    r = z_write_field_uint8(buffer, 1, msg->log_level);
    if (Z_UNLIKELY(r)) return(-1);
  }
  return(r);
}

void server_debug_request_dump (FILE *stream, const struct server_debug_request *msg) {
  fprintf(stream, "server_debug_request {");
  
  fprintf(stream, "\n  1: uint8 log_level = ");
  if (server_debug_request_has_log_level(msg)) {
    z_dump_uint8(stream, msg->log_level);
  } else {
    fprintf(stream, "MISSING");
  }
  fprintf(stream, "\n}\n");
}

struct server_debug_response *server_debug_response_alloc (struct server_debug_response *msg) {
  if (msg == NULL) {
    msg = z_memory_struct_alloc(z_global_memory(), struct server_debug_response);
    if (Z_MALLOC_IS_NULL(msg))
      return(NULL);
    msg->server_debug_response_ialloc = 1;
  } else {
    msg->server_debug_response_ialloc = 0;
  }

  z_memzero(msg->server_debug_response_fields_bitmap, 0);

  return(msg);
}

void server_debug_response_free (struct server_debug_response *msg) {

  if (msg->server_debug_response_ialloc)
    z_memory_struct_free(z_global_memory(), struct server_debug_response, msg);
}

int server_debug_response_parse (struct server_debug_response *msg, void *reader, uint64_t size) {
  uint64_t total_length = 0;
  uint16_t field_id;
  uint64_t length;
  int r = 0;

  while (z_reader_decode_field(reader, &field_id, &length) > 0) {
    switch (field_id) {
      

      default: {
        r = -1;
        if (z_reader_skip(reader, length))
          return(-1);
        break;
      }
    }

    total_length += length;
    if (Z_UNLIKELY(total_length >= size))
      break;
  }

  return(r);
}

size_t server_debug_response_size (struct server_debug_response *msg) {
  size_t size = 0;
  
  return(size);
}

int server_debug_response_write (struct server_debug_response *msg, z_buffer_t *buffer) {
  int r = 0;
  
  return(r);
}

void server_debug_response_dump (FILE *stream, const struct server_debug_response *msg) {
  fprintf(stream, "server_debug_response {");
  
  fprintf(stream, "\n}\n");
}