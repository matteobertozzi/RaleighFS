
/*
 * File autogenerated, do not edit.
 * (this file should be part of the client library)
 */
#include <zcl/string.h>
#include <zcl/global.h>
#include <zcl/iovec.h>
#include <zcl/debug.h>
#include <zcl/time.h>

#include "rpc_client.h"


static int __raleighsl_rpc_client_parse_request (z_iovec_reader_t *reader,
                                                 uint64_t msg_type,
                                                 uint64_t req_id)
{
  return(-1);
}

static int __raleighsl_rpc_client_parse_response (z_iovec_reader_t *reader,
                                                  z_rpc_map_t *rpc_map,
                                                  uint64_t msg_type,
                                                  uint64_t req_id)
{
  z_rpc_call_t *call;
  uint64_t size;
  int r = -1;

  size = z_reader_available(reader);
  call = z_rpc_map_remove(rpc_map, req_id);

  switch (msg_type) {

    case SEMANTIC_OPEN_ID: {
      struct semantic_open_response *resp = NULL;

      resp = semantic_open_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response semantic_open_response");
        /* TODO */
        break;
      }

      if ((r = semantic_open_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        semantic_open_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      semantic_open_response_free(resp);
      /* TODO */
      break;
    }

    case SEMANTIC_CREATE_ID: {
      struct semantic_create_response *resp = NULL;

      resp = semantic_create_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response semantic_create_response");
        /* TODO */
        break;
      }

      if ((r = semantic_create_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        semantic_create_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      semantic_create_response_free(resp);
      /* TODO */
      break;
    }

    case SEMANTIC_DELETE_ID: {
      struct semantic_delete_response *resp = NULL;

      resp = semantic_delete_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response semantic_delete_response");
        /* TODO */
        break;
      }

      if ((r = semantic_delete_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        semantic_delete_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      semantic_delete_response_free(resp);
      /* TODO */
      break;
    }

    case SEMANTIC_RENAME_ID: {
      struct semantic_rename_response *resp = NULL;

      resp = semantic_rename_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response semantic_rename_response");
        /* TODO */
        break;
      }

      if ((r = semantic_rename_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        semantic_rename_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      semantic_rename_response_free(resp);
      /* TODO */
      break;
    }

    case TRANSACTION_CREATE_ID: {
      struct transaction_create_response *resp = NULL;

      resp = transaction_create_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response transaction_create_response");
        /* TODO */
        break;
      }

      if ((r = transaction_create_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        transaction_create_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      transaction_create_response_free(resp);
      /* TODO */
      break;
    }

    case TRANSACTION_COMMIT_ID: {
      struct transaction_commit_response *resp = NULL;

      resp = transaction_commit_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response transaction_commit_response");
        /* TODO */
        break;
      }

      if ((r = transaction_commit_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        transaction_commit_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      transaction_commit_response_free(resp);
      /* TODO */
      break;
    }

    case TRANSACTION_ROLLBACK_ID: {
      struct transaction_rollback_response *resp = NULL;

      resp = transaction_rollback_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response transaction_rollback_response");
        /* TODO */
        break;
      }

      if ((r = transaction_rollback_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        transaction_rollback_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      transaction_rollback_response_free(resp);
      /* TODO */
      break;
    }

    case NUMBER_GET_ID: {
      struct number_get_response *resp = NULL;

      resp = number_get_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response number_get_response");
        /* TODO */
        break;
      }

      if ((r = number_get_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        number_get_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      number_get_response_free(resp);
      /* TODO */
      break;
    }

    case NUMBER_SET_ID: {
      struct number_set_response *resp = NULL;

      resp = number_set_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response number_set_response");
        /* TODO */
        break;
      }

      if ((r = number_set_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        number_set_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      number_set_response_free(resp);
      /* TODO */
      break;
    }

    case NUMBER_CAS_ID: {
      struct number_cas_response *resp = NULL;

      resp = number_cas_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response number_cas_response");
        /* TODO */
        break;
      }

      if ((r = number_cas_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        number_cas_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      number_cas_response_free(resp);
      /* TODO */
      break;
    }

    case NUMBER_ADD_ID: {
      struct number_add_response *resp = NULL;

      resp = number_add_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response number_add_response");
        /* TODO */
        break;
      }

      if ((r = number_add_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        number_add_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      number_add_response_free(resp);
      /* TODO */
      break;
    }

    case NUMBER_MUL_ID: {
      struct number_mul_response *resp = NULL;

      resp = number_mul_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response number_mul_response");
        /* TODO */
        break;
      }

      if ((r = number_mul_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        number_mul_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      number_mul_response_free(resp);
      /* TODO */
      break;
    }

    case NUMBER_DIV_ID: {
      struct number_div_response *resp = NULL;

      resp = number_div_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response number_div_response");
        /* TODO */
        break;
      }

      if ((r = number_div_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        number_div_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      number_div_response_free(resp);
      /* TODO */
      break;
    }

    case SSET_INSERT_ID: {
      struct sset_insert_response *resp = NULL;

      resp = sset_insert_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response sset_insert_response");
        /* TODO */
        break;
      }

      if ((r = sset_insert_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        sset_insert_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      sset_insert_response_free(resp);
      /* TODO */
      break;
    }

    case SSET_UPDATE_ID: {
      struct sset_update_response *resp = NULL;

      resp = sset_update_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response sset_update_response");
        /* TODO */
        break;
      }

      if ((r = sset_update_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        sset_update_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      sset_update_response_free(resp);
      /* TODO */
      break;
    }

    case SSET_POP_ID: {
      struct sset_pop_response *resp = NULL;

      resp = sset_pop_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response sset_pop_response");
        /* TODO */
        break;
      }

      if ((r = sset_pop_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        sset_pop_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      sset_pop_response_free(resp);
      /* TODO */
      break;
    }

    case SSET_GET_ID: {
      struct sset_get_response *resp = NULL;

      resp = sset_get_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response sset_get_response");
        /* TODO */
        break;
      }

      if ((r = sset_get_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        sset_get_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      sset_get_response_free(resp);
      /* TODO */
      break;
    }

    case SSET_SCAN_ID: {
      struct sset_scan_response *resp = NULL;

      resp = sset_scan_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response sset_scan_response");
        /* TODO */
        break;
      }

      if ((r = sset_scan_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        sset_scan_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      sset_scan_response_free(resp);
      /* TODO */
      break;
    }

    case FLOW_APPEND_ID: {
      struct flow_append_response *resp = NULL;

      resp = flow_append_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response flow_append_response");
        /* TODO */
        break;
      }

      if ((r = flow_append_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        flow_append_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      flow_append_response_free(resp);
      /* TODO */
      break;
    }

    case FLOW_INJECT_ID: {
      struct flow_inject_response *resp = NULL;

      resp = flow_inject_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response flow_inject_response");
        /* TODO */
        break;
      }

      if ((r = flow_inject_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        flow_inject_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      flow_inject_response_free(resp);
      /* TODO */
      break;
    }

    case FLOW_WRITE_ID: {
      struct flow_write_response *resp = NULL;

      resp = flow_write_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response flow_write_response");
        /* TODO */
        break;
      }

      if ((r = flow_write_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        flow_write_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      flow_write_response_free(resp);
      /* TODO */
      break;
    }

    case FLOW_REMOVE_ID: {
      struct flow_remove_response *resp = NULL;

      resp = flow_remove_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response flow_remove_response");
        /* TODO */
        break;
      }

      if ((r = flow_remove_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        flow_remove_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      flow_remove_response_free(resp);
      /* TODO */
      break;
    }

    case FLOW_TRUNCATE_ID: {
      struct flow_truncate_response *resp = NULL;

      resp = flow_truncate_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response flow_truncate_response");
        /* TODO */
        break;
      }

      if ((r = flow_truncate_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        flow_truncate_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      flow_truncate_response_free(resp);
      /* TODO */
      break;
    }

    case FLOW_READ_ID: {
      struct flow_read_response *resp = NULL;

      resp = flow_read_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response flow_read_response");
        /* TODO */
        break;
      }

      if ((r = flow_read_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        flow_read_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      flow_read_response_free(resp);
      /* TODO */
      break;
    }

    case DEQUE_PUSH_ID: {
      struct deque_push_response *resp = NULL;

      resp = deque_push_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response deque_push_response");
        /* TODO */
        break;
      }

      if ((r = deque_push_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        deque_push_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      deque_push_response_free(resp);
      /* TODO */
      break;
    }

    case DEQUE_POP_ID: {
      struct deque_pop_response *resp = NULL;

      resp = deque_pop_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response deque_pop_response");
        /* TODO */
        break;
      }

      if ((r = deque_pop_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        deque_pop_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      deque_pop_response_free(resp);
      /* TODO */
      break;
    }

    case SERVER_PING_ID: {
      struct server_ping_response *resp = NULL;

      resp = server_ping_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response server_ping_response");
        /* TODO */
        break;
      }

      if ((r = server_ping_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        server_ping_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      server_ping_response_free(resp);
      /* TODO */
      break;
    }

    case SERVER_INFO_ID: {
      struct server_info_response *resp = NULL;

      resp = server_info_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response server_info_response");
        /* TODO */
        break;
      }

      if ((r = server_info_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        server_info_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      server_info_response_free(resp);
      /* TODO */
      break;
    }

    case SERVER_QUIT_ID: {
      struct server_quit_response *resp = NULL;

      resp = server_quit_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response server_quit_response");
        /* TODO */
        break;
      }

      if ((r = server_quit_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        server_quit_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      server_quit_response_free(resp);
      /* TODO */
      break;
    }

    case SERVER_DEBUG_ID: {
      struct server_debug_response *resp = NULL;

      resp = server_debug_response_alloc(resp);
      if (Z_MALLOC_IS_NULL(resp)) {
        Z_LOG_FATAL("Unable to allocate response server_debug_response");
        /* TODO */
        break;
      }

      if ((r = server_debug_response_parse(resp, reader, size))) {
        Z_LOG_FATAL("Unable to parse message {REQ_ATYPE}");
        server_debug_response_free(resp);
        /* TODO */
        break;
      }

      call->callback(call->ctx, call->ucallback, call->udata);
      server_debug_response_free(resp);
      /* TODO */
      break;
    }

    default:
      /* ctx->handle_unknown(client, Z_IPC_UNKNOWN_MESSAGE, msg_type, req_id); */
      Z_LOG_FATAL("Unknown type %u for response %u", msg_type, req_id);
      break;
  }

  return(r);
}

int raleighsl_rpc_client_parse (z_iopoll_entity_t *client,
                                z_rpc_map_t *rpc_map,
                                const struct iovec iov[2])
{
  z_iovec_reader_t reader;
  uint64_t msg_type;
  uint64_t req_id;
  int is_req;
  int r = -1;

  z_iovec_reader_open(&reader, iov, 2);

  /* Parse the RPC header */
  if (z_rpc_parse_head(&reader, &msg_type, &req_id, &is_req)) {
    Z_LOG_FATAL("Unable to read the Request-Head from the RPC header");
    return(-1);
  }

  if (Z_UNLIKELY(is_req)) {
    r = __raleighsl_rpc_client_parse_request(&reader, msg_type, req_id);
  } else {
    r = __raleighsl_rpc_client_parse_response(&reader, rpc_map, msg_type, req_id);
  }

  z_iovec_reader_close(&reader);
  return(r);
}

z_rpc_ctx_t *raleighsl_rpc_client_build_request (z_iopoll_entity_t *client,
                                                 uint64_t msg_type,
                                                 uint64_t req_id)
{
  z_rpc_ctx_t *ctx;

  switch (msg_type) {

    case SEMANTIC_OPEN_ID: {
      ctx = z_rpc_ctx_alloc(struct semantic_open_request, struct semantic_open_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context semantic_open");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct semantic_open_request);
      semantic_open_request_alloc(Z_RPC_CTX_REQ(struct semantic_open_request, ctx));
      semantic_open_response_alloc(Z_RPC_CTX_RESP(struct semantic_open_response, ctx));
      break;
    }

    case SEMANTIC_CREATE_ID: {
      ctx = z_rpc_ctx_alloc(struct semantic_create_request, struct semantic_create_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context semantic_create");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct semantic_create_request);
      semantic_create_request_alloc(Z_RPC_CTX_REQ(struct semantic_create_request, ctx));
      semantic_create_response_alloc(Z_RPC_CTX_RESP(struct semantic_create_response, ctx));
      break;
    }

    case SEMANTIC_DELETE_ID: {
      ctx = z_rpc_ctx_alloc(struct semantic_delete_request, struct semantic_delete_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context semantic_delete");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct semantic_delete_request);
      semantic_delete_request_alloc(Z_RPC_CTX_REQ(struct semantic_delete_request, ctx));
      semantic_delete_response_alloc(Z_RPC_CTX_RESP(struct semantic_delete_response, ctx));
      break;
    }

    case SEMANTIC_RENAME_ID: {
      ctx = z_rpc_ctx_alloc(struct semantic_rename_request, struct semantic_rename_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context semantic_rename");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct semantic_rename_request);
      semantic_rename_request_alloc(Z_RPC_CTX_REQ(struct semantic_rename_request, ctx));
      semantic_rename_response_alloc(Z_RPC_CTX_RESP(struct semantic_rename_response, ctx));
      break;
    }

    case TRANSACTION_CREATE_ID: {
      ctx = z_rpc_ctx_alloc(struct transaction_create_request, struct transaction_create_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context transaction_create");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct transaction_create_request);
      transaction_create_request_alloc(Z_RPC_CTX_REQ(struct transaction_create_request, ctx));
      transaction_create_response_alloc(Z_RPC_CTX_RESP(struct transaction_create_response, ctx));
      break;
    }

    case TRANSACTION_COMMIT_ID: {
      ctx = z_rpc_ctx_alloc(struct transaction_commit_request, struct transaction_commit_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context transaction_commit");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct transaction_commit_request);
      transaction_commit_request_alloc(Z_RPC_CTX_REQ(struct transaction_commit_request, ctx));
      transaction_commit_response_alloc(Z_RPC_CTX_RESP(struct transaction_commit_response, ctx));
      break;
    }

    case TRANSACTION_ROLLBACK_ID: {
      ctx = z_rpc_ctx_alloc(struct transaction_rollback_request, struct transaction_rollback_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context transaction_rollback");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct transaction_rollback_request);
      transaction_rollback_request_alloc(Z_RPC_CTX_REQ(struct transaction_rollback_request, ctx));
      transaction_rollback_response_alloc(Z_RPC_CTX_RESP(struct transaction_rollback_response, ctx));
      break;
    }

    case NUMBER_GET_ID: {
      ctx = z_rpc_ctx_alloc(struct number_get_request, struct number_get_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context number_get");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct number_get_request);
      number_get_request_alloc(Z_RPC_CTX_REQ(struct number_get_request, ctx));
      number_get_response_alloc(Z_RPC_CTX_RESP(struct number_get_response, ctx));
      break;
    }

    case NUMBER_SET_ID: {
      ctx = z_rpc_ctx_alloc(struct number_set_request, struct number_set_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context number_set");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct number_set_request);
      number_set_request_alloc(Z_RPC_CTX_REQ(struct number_set_request, ctx));
      number_set_response_alloc(Z_RPC_CTX_RESP(struct number_set_response, ctx));
      break;
    }

    case NUMBER_CAS_ID: {
      ctx = z_rpc_ctx_alloc(struct number_cas_request, struct number_cas_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context number_cas");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct number_cas_request);
      number_cas_request_alloc(Z_RPC_CTX_REQ(struct number_cas_request, ctx));
      number_cas_response_alloc(Z_RPC_CTX_RESP(struct number_cas_response, ctx));
      break;
    }

    case NUMBER_ADD_ID: {
      ctx = z_rpc_ctx_alloc(struct number_add_request, struct number_add_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context number_add");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct number_add_request);
      number_add_request_alloc(Z_RPC_CTX_REQ(struct number_add_request, ctx));
      number_add_response_alloc(Z_RPC_CTX_RESP(struct number_add_response, ctx));
      break;
    }

    case NUMBER_MUL_ID: {
      ctx = z_rpc_ctx_alloc(struct number_mul_request, struct number_mul_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context number_mul");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct number_mul_request);
      number_mul_request_alloc(Z_RPC_CTX_REQ(struct number_mul_request, ctx));
      number_mul_response_alloc(Z_RPC_CTX_RESP(struct number_mul_response, ctx));
      break;
    }

    case NUMBER_DIV_ID: {
      ctx = z_rpc_ctx_alloc(struct number_div_request, struct number_div_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context number_div");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct number_div_request);
      number_div_request_alloc(Z_RPC_CTX_REQ(struct number_div_request, ctx));
      number_div_response_alloc(Z_RPC_CTX_RESP(struct number_div_response, ctx));
      break;
    }

    case SSET_INSERT_ID: {
      ctx = z_rpc_ctx_alloc(struct sset_insert_request, struct sset_insert_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context sset_insert");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct sset_insert_request);
      sset_insert_request_alloc(Z_RPC_CTX_REQ(struct sset_insert_request, ctx));
      sset_insert_response_alloc(Z_RPC_CTX_RESP(struct sset_insert_response, ctx));
      break;
    }

    case SSET_UPDATE_ID: {
      ctx = z_rpc_ctx_alloc(struct sset_update_request, struct sset_update_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context sset_update");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct sset_update_request);
      sset_update_request_alloc(Z_RPC_CTX_REQ(struct sset_update_request, ctx));
      sset_update_response_alloc(Z_RPC_CTX_RESP(struct sset_update_response, ctx));
      break;
    }

    case SSET_POP_ID: {
      ctx = z_rpc_ctx_alloc(struct sset_pop_request, struct sset_pop_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context sset_pop");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct sset_pop_request);
      sset_pop_request_alloc(Z_RPC_CTX_REQ(struct sset_pop_request, ctx));
      sset_pop_response_alloc(Z_RPC_CTX_RESP(struct sset_pop_response, ctx));
      break;
    }

    case SSET_GET_ID: {
      ctx = z_rpc_ctx_alloc(struct sset_get_request, struct sset_get_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context sset_get");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct sset_get_request);
      sset_get_request_alloc(Z_RPC_CTX_REQ(struct sset_get_request, ctx));
      sset_get_response_alloc(Z_RPC_CTX_RESP(struct sset_get_response, ctx));
      break;
    }

    case SSET_SCAN_ID: {
      ctx = z_rpc_ctx_alloc(struct sset_scan_request, struct sset_scan_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context sset_scan");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct sset_scan_request);
      sset_scan_request_alloc(Z_RPC_CTX_REQ(struct sset_scan_request, ctx));
      sset_scan_response_alloc(Z_RPC_CTX_RESP(struct sset_scan_response, ctx));
      break;
    }

    case FLOW_APPEND_ID: {
      ctx = z_rpc_ctx_alloc(struct flow_append_request, struct flow_append_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context flow_append");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct flow_append_request);
      flow_append_request_alloc(Z_RPC_CTX_REQ(struct flow_append_request, ctx));
      flow_append_response_alloc(Z_RPC_CTX_RESP(struct flow_append_response, ctx));
      break;
    }

    case FLOW_INJECT_ID: {
      ctx = z_rpc_ctx_alloc(struct flow_inject_request, struct flow_inject_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context flow_inject");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct flow_inject_request);
      flow_inject_request_alloc(Z_RPC_CTX_REQ(struct flow_inject_request, ctx));
      flow_inject_response_alloc(Z_RPC_CTX_RESP(struct flow_inject_response, ctx));
      break;
    }

    case FLOW_WRITE_ID: {
      ctx = z_rpc_ctx_alloc(struct flow_write_request, struct flow_write_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context flow_write");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct flow_write_request);
      flow_write_request_alloc(Z_RPC_CTX_REQ(struct flow_write_request, ctx));
      flow_write_response_alloc(Z_RPC_CTX_RESP(struct flow_write_response, ctx));
      break;
    }

    case FLOW_REMOVE_ID: {
      ctx = z_rpc_ctx_alloc(struct flow_remove_request, struct flow_remove_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context flow_remove");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct flow_remove_request);
      flow_remove_request_alloc(Z_RPC_CTX_REQ(struct flow_remove_request, ctx));
      flow_remove_response_alloc(Z_RPC_CTX_RESP(struct flow_remove_response, ctx));
      break;
    }

    case FLOW_TRUNCATE_ID: {
      ctx = z_rpc_ctx_alloc(struct flow_truncate_request, struct flow_truncate_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context flow_truncate");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct flow_truncate_request);
      flow_truncate_request_alloc(Z_RPC_CTX_REQ(struct flow_truncate_request, ctx));
      flow_truncate_response_alloc(Z_RPC_CTX_RESP(struct flow_truncate_response, ctx));
      break;
    }

    case FLOW_READ_ID: {
      ctx = z_rpc_ctx_alloc(struct flow_read_request, struct flow_read_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context flow_read");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct flow_read_request);
      flow_read_request_alloc(Z_RPC_CTX_REQ(struct flow_read_request, ctx));
      flow_read_response_alloc(Z_RPC_CTX_RESP(struct flow_read_response, ctx));
      break;
    }

    case DEQUE_PUSH_ID: {
      ctx = z_rpc_ctx_alloc(struct deque_push_request, struct deque_push_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context deque_push");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct deque_push_request);
      deque_push_request_alloc(Z_RPC_CTX_REQ(struct deque_push_request, ctx));
      deque_push_response_alloc(Z_RPC_CTX_RESP(struct deque_push_response, ctx));
      break;
    }

    case DEQUE_POP_ID: {
      ctx = z_rpc_ctx_alloc(struct deque_pop_request, struct deque_pop_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context deque_pop");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct deque_pop_request);
      deque_pop_request_alloc(Z_RPC_CTX_REQ(struct deque_pop_request, ctx));
      deque_pop_response_alloc(Z_RPC_CTX_RESP(struct deque_pop_response, ctx));
      break;
    }

    case SERVER_PING_ID: {
      ctx = z_rpc_ctx_alloc(struct server_ping_request, struct server_ping_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context server_ping");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct server_ping_request);
      server_ping_request_alloc(Z_RPC_CTX_REQ(struct server_ping_request, ctx));
      server_ping_response_alloc(Z_RPC_CTX_RESP(struct server_ping_response, ctx));
      break;
    }

    case SERVER_INFO_ID: {
      ctx = z_rpc_ctx_alloc(struct server_info_request, struct server_info_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context server_info");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct server_info_request);
      server_info_request_alloc(Z_RPC_CTX_REQ(struct server_info_request, ctx));
      server_info_response_alloc(Z_RPC_CTX_RESP(struct server_info_response, ctx));
      break;
    }

    case SERVER_QUIT_ID: {
      ctx = z_rpc_ctx_alloc(struct server_quit_request, struct server_quit_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context server_quit");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct server_quit_request);
      server_quit_request_alloc(Z_RPC_CTX_REQ(struct server_quit_request, ctx));
      server_quit_response_alloc(Z_RPC_CTX_RESP(struct server_quit_response, ctx));
      break;
    }

    case SERVER_DEBUG_ID: {
      ctx = z_rpc_ctx_alloc(struct server_debug_request, struct server_debug_response);
      if (Z_MALLOC_IS_NULL(ctx)) {
        Z_LOG_FATAL("Unable to allocate rpc context server_debug");
        return(NULL);
      }

      /* TODO: CHECK ME! */
      z_rpc_ctx_init(ctx, struct server_debug_request);
      server_debug_request_alloc(Z_RPC_CTX_REQ(struct server_debug_request, ctx));
      server_debug_response_alloc(Z_RPC_CTX_RESP(struct server_debug_response, ctx));
      break;
    }

    default:
      Z_LOG_FATAL("Unknown type %"PRIu64" for request\n", msg_type);
      return(NULL);
  }

  ctx->client   = client;
  ctx->req_id   = req_id;
  ctx->req_time = z_time_micros();
  ctx->msg_type = msg_type;
  return(ctx);
}

int raleighsl_rpc_client_push_request (z_iopoll_t *iopoll,
                                       z_rpc_ctx_t *ctx,
                                       z_ipc_msgbuf_t *msgbuf,
                                       z_rpc_map_t *rpc_map,
                                       void *sys_callback,
                                       void *ucallback,
                                       void *udata)
{
  z_rpc_call_t *call;
  z_buffer_t buffer;
  int r = -1;

  call = z_rpc_map_add(rpc_map, ctx, sys_callback, ucallback, udata);
  if (Z_MALLOC_IS_NULL(call)) {
    return(-1);
  }

  if (Z_UNLIKELY(z_buffer_alloc(&buffer) == NULL)) {
    Z_LOG_FATAL("TODO unable to allocate buffer (free req/resp)\n");
    return(-1);
  }

  if (Z_UNLIKELY(z_buffer_reserve(&buffer, 128))) {
    Z_LOG_FATAL("TODO unable to reserve buffer space (free req/resp)\n");
    return(-1);
  }

  /* Write the RPC header */
  buffer.size = z_rpc_write_head(buffer.block, ctx->msg_type, ctx->req_id, 1);

  /* Write the Response */
  switch (ctx->msg_type) {

    case SEMANTIC_OPEN_ID: {
      r = semantic_open_request_write(Z_RPC_CTX_REQ(struct semantic_open_request, ctx), &buffer);
      break;
    }

    case SEMANTIC_CREATE_ID: {
      r = semantic_create_request_write(Z_RPC_CTX_REQ(struct semantic_create_request, ctx), &buffer);
      break;
    }

    case SEMANTIC_DELETE_ID: {
      r = semantic_delete_request_write(Z_RPC_CTX_REQ(struct semantic_delete_request, ctx), &buffer);
      break;
    }

    case SEMANTIC_RENAME_ID: {
      r = semantic_rename_request_write(Z_RPC_CTX_REQ(struct semantic_rename_request, ctx), &buffer);
      break;
    }

    case TRANSACTION_CREATE_ID: {
      r = transaction_create_request_write(Z_RPC_CTX_REQ(struct transaction_create_request, ctx), &buffer);
      break;
    }

    case TRANSACTION_COMMIT_ID: {
      r = transaction_commit_request_write(Z_RPC_CTX_REQ(struct transaction_commit_request, ctx), &buffer);
      break;
    }

    case TRANSACTION_ROLLBACK_ID: {
      r = transaction_rollback_request_write(Z_RPC_CTX_REQ(struct transaction_rollback_request, ctx), &buffer);
      break;
    }

    case NUMBER_GET_ID: {
      r = number_get_request_write(Z_RPC_CTX_REQ(struct number_get_request, ctx), &buffer);
      break;
    }

    case NUMBER_SET_ID: {
      r = number_set_request_write(Z_RPC_CTX_REQ(struct number_set_request, ctx), &buffer);
      break;
    }

    case NUMBER_CAS_ID: {
      r = number_cas_request_write(Z_RPC_CTX_REQ(struct number_cas_request, ctx), &buffer);
      break;
    }

    case NUMBER_ADD_ID: {
      r = number_add_request_write(Z_RPC_CTX_REQ(struct number_add_request, ctx), &buffer);
      break;
    }

    case NUMBER_MUL_ID: {
      r = number_mul_request_write(Z_RPC_CTX_REQ(struct number_mul_request, ctx), &buffer);
      break;
    }

    case NUMBER_DIV_ID: {
      r = number_div_request_write(Z_RPC_CTX_REQ(struct number_div_request, ctx), &buffer);
      break;
    }

    case SSET_INSERT_ID: {
      r = sset_insert_request_write(Z_RPC_CTX_REQ(struct sset_insert_request, ctx), &buffer);
      break;
    }

    case SSET_UPDATE_ID: {
      r = sset_update_request_write(Z_RPC_CTX_REQ(struct sset_update_request, ctx), &buffer);
      break;
    }

    case SSET_POP_ID: {
      r = sset_pop_request_write(Z_RPC_CTX_REQ(struct sset_pop_request, ctx), &buffer);
      break;
    }

    case SSET_GET_ID: {
      r = sset_get_request_write(Z_RPC_CTX_REQ(struct sset_get_request, ctx), &buffer);
      break;
    }

    case SSET_SCAN_ID: {
      r = sset_scan_request_write(Z_RPC_CTX_REQ(struct sset_scan_request, ctx), &buffer);
      break;
    }

    case FLOW_APPEND_ID: {
      r = flow_append_request_write(Z_RPC_CTX_REQ(struct flow_append_request, ctx), &buffer);
      break;
    }

    case FLOW_INJECT_ID: {
      r = flow_inject_request_write(Z_RPC_CTX_REQ(struct flow_inject_request, ctx), &buffer);
      break;
    }

    case FLOW_WRITE_ID: {
      r = flow_write_request_write(Z_RPC_CTX_REQ(struct flow_write_request, ctx), &buffer);
      break;
    }

    case FLOW_REMOVE_ID: {
      r = flow_remove_request_write(Z_RPC_CTX_REQ(struct flow_remove_request, ctx), &buffer);
      break;
    }

    case FLOW_TRUNCATE_ID: {
      r = flow_truncate_request_write(Z_RPC_CTX_REQ(struct flow_truncate_request, ctx), &buffer);
      break;
    }

    case FLOW_READ_ID: {
      r = flow_read_request_write(Z_RPC_CTX_REQ(struct flow_read_request, ctx), &buffer);
      break;
    }

    case DEQUE_PUSH_ID: {
      r = deque_push_request_write(Z_RPC_CTX_REQ(struct deque_push_request, ctx), &buffer);
      break;
    }

    case DEQUE_POP_ID: {
      r = deque_pop_request_write(Z_RPC_CTX_REQ(struct deque_pop_request, ctx), &buffer);
      break;
    }

    case SERVER_PING_ID: {
      r = server_ping_request_write(Z_RPC_CTX_REQ(struct server_ping_request, ctx), &buffer);
      break;
    }

    case SERVER_INFO_ID: {
      r = server_info_request_write(Z_RPC_CTX_REQ(struct server_info_request, ctx), &buffer);
      break;
    }

    case SERVER_QUIT_ID: {
      r = server_quit_request_write(Z_RPC_CTX_REQ(struct server_quit_request, ctx), &buffer);
      break;
    }

    case SERVER_DEBUG_ID: {
      r = server_debug_request_write(Z_RPC_CTX_REQ(struct server_debug_request, ctx), &buffer);
      break;
    }

    default:
      Z_LOG_FATAL("Unknown type %"PRIu64" for request\n", ctx->msg_type);
      break;
  }

  if (Z_UNLIKELY(r == 0)) {
    r = z_ipc_msgbuf_push(msgbuf, buffer.block, buffer.size);
    z_iopoll_set_writable(iopoll, ctx->client, 1);
    Z_LOG_TRACE("Send request of size=%zu time=%.5fsec",
                buffer.size, (z_time_micros() - ctx->req_time) / 1000000.0f);

    z_buffer_release(&buffer);
  }

  z_buffer_free(&buffer);
  return(r);
}